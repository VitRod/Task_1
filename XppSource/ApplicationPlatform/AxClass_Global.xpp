using Microsoft.Dynamics.ApplicationPlatform.Environment;
using Microsoft.Dynamics.ApplicationPlatform.Environment.Settings;
using Microsoft.Dynamics.ApplicationPlatform.XppServices.Instrumentation;

// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
public static class Global
{
    #define.CSBoolean('System.Boolean')
    #define.ATTR_TYPE('type')
    #define.ATTR_KEY_TYPE('keytype')
    #define.ATTR_VALUE_TYPE('valuetype')
    // <GJP>
    #DateFormat_JP
    // </GJP>

    #define.VIRTUALCOMPANYLIST('virtualcompanylist')
    #define.ISVIRTUALCOMPANY('isvirtualcompany')

    /// <summary>
    /// Ifx logging category name
    /// </summary>
    const str EncryptDecryptCategoryName = "EncryptDecrypt";

    static Dictionary dict = new Dictionary();
    private static UnknownNoYes debugFlags = UnknownNoYes::Unknown;
    private static Map clientDebugFlags = new Map(Types::String, Types::Enum);
    internal static boolean extendedSerialization = false;
    private static boolean isPreviewBuild;
    private static boolean isPreviewBuildCalculated = false;
    private static boolean isAppEmbedded;
    private static boolean isAppEmbeddedCalculated = false;
    [SysObsolete('NPS configuration is now controlled via SysClientNpsManager', false, 17\03\2023)]
    private static boolean isNpsEnabled;
    [SysObsolete('NPS configuration is now controlled via SysClientNpsManager', false, 17\03\2023)]
    internal static boolean isNpsEnabledProcessed = false;
    private static DeploymentEndpoint deploymentEndPoint;
    internal static boolean isEndPointProcessed;
    private static str hostUrlFormatOverride;

    // used for extended serialization scenarios, to properly set the grounds for versioning
    private const int globalXMLSerializationVersion = 1;
    private const str errorDefaultInstanceNotFound = 'Instance retrieved from the service registry is null for type %1';
    // These 4 items are for the container returned by GetModuleBuildInfo
    private const int VersionMajor = 1; 
    private const int VersionMinor = 2;
    private const int VersionBuild = 3;
    private const int VersionRevision = 4;

    /// <summary>
    /// Creates a new instance of the Dataverse client that must be used to communicate to the Dataverse organization.
    /// </summary>
    [Hookable(false)]
    public static Microsoft.Xrm.Sdk.IOrganizationService getDataverseClient()
    {
        Microsoft.Dynamics.DataverseSdk.StrongConsistencyDataverseOrganizationServiceFactory organizationServiceFactory = 
            new Microsoft.Dynamics.DataverseSdk.StrongConsistencyDataverseOrganizationServiceFactory(
                'getDataverseClient',
                Microsoft.Dynamics.Ax.Xpp.Dataverse.SysDataverseUtil::GetFuncApplTtsLevel(),
                Microsoft.Dynamics.Ax.Xpp.Dataverse.SysDataverseUtil::GetFuncCurrentUserId(),
                Microsoft.Dynamics.Ax.Xpp.Dataverse.SysDataverseUtil::GetSqlBindingToken());

        guid currentObjectId = curUserGuid();
        Microsoft.Dynamics.DataverseSdk.SysDataverseClient dataverseClient = organizationServiceFactory.CreateOrganizationService(currentObjectId);

        return dataverseClient as Microsoft.Xrm.Sdk.IOrganizationService;
    }

    /// <summary>
    ///     Converts a string value to an enumeration value if possible.
    /// </summary>
    /// <param name = "_enumId">
    ///     The ID of the enumeration.
    /// </param>
    /// <param name = "_value">
    ///     The string value being parsed as an enum symbol.
    /// </param>
    /// <param name = "_outEnumValue">
    ///     Outputs the parsed enumeration value.
    /// </param>
    /// <returns>
    ///     true if the parsing succeeded; otherwise, false.
    /// </returns>
    public static boolean tryParseEnumValue(EnumId _enumId, str _strValue, SysAnyType _outEnumValue)
    {
        var enumerationDictionary = new SysDictEnum(_enumId);
        Counter     enumChoices   = enumerationDictionary.values();
        boolean     success = false;
        Counter     idx;

        for (idx = 0; idx < enumChoices; idx++)
        {
            if (enumerationDictionary.index2Symbol(idx) == _strValue)
            {
                success = true;
                _outEnumValue.value(enumerationDictionary.index2Value(idx));
                break;
            }
        }

        return success;
    }

    /// <summary>
    /// Calculates the accelerated depreciation of an asset.
    /// </summary>
    /// <param name="price">
    /// The purchase price of the asset.
    /// </param>
    /// <param name="scrap">
    /// The residual value of the asset that has been written off.
    /// </param>
    /// <param name="life">
    /// The expected lifetime of the asset.
    /// </param>
    /// <param name="period">
    /// The period over which to calculate depreciation.
    /// </param>
    /// <returns>
    /// The depreciation of the asset.
    /// </returns>
    /// <remarks>
    /// This method is a rename of the <c>ddb</c> method.
    /// </remarks>
    static real acceleratedDepreciation(real price, real scrap, real life, int period)
    {
        return ddb(price, scrap, life, period);
    }

    /// <summary>
    /// Converts a <c>AccessRight</c> enumeration type into a <c>NeededPermission</c> enumeration type.
    /// </summary>
    /// <param name="_accessRight">
    /// The <c>AccessRight</c> enumeration type to convert.
    /// </param>
    /// <returns>
    /// The converted <c>NeededPermission</c> enumeration type.
    /// </returns>
    public static NeededPermission accessRight2NeededPermission(AccessRight _accessRight)
    {
        var neededPermission = NeededPermission::None;

        switch (_accessRight)
        {
            case AccessRight::View:
                neededPermission = NeededPermission::Read;
                break;

            case AccessRight::Edit:
                neededPermission = NeededPermission::Update;
                break;

            case AccessRight::Add:
                neededPermission = NeededPermission::Create;
                break;

            case AccessRight::Correction:
                neededPermission = NeededPermission::Correct;
                break;

            case AccessRight::Delete:
                neededPermission = NeededPermission::Delete;
                break;

            default:
                neededPermission = NeededPermission::None;
                break;
        }

        return neededPermission;
    }

    public static void allowEditFieldsOnFormDS_W(FormDataSource _dataSource, boolean _allowEdit)
    {
        var dictTable = new DictTable(_dataSource.table());
        int         cx, idx;

        for (cx = 1; cx <= dictTable.fieldCnt(); cx ++)
        {
            DictField dictField = dictTable.fieldObject(dictTable.fieldCnt2Id(cx));

            if (! dictField.isSystem())
            {
                for (idx = 1; idx <= dictField.arraySize(); idx++)
                {
                    FormDataObject dataObject = _dataSource.object(fieldId2Ext(dictField.id(), idx));
                    if (dataObject)
                    {
                        dataObject.allowEdit(_allowEdit);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Explicitly converts an object of any type to x++ <c>Object</c> class.
    /// </summary>
    /// <param name="_value">
    /// The value to convert.
    /// </param>
    /// <returns>
    /// The object representation of the value.
    /// </returns>
    public static Object any2Object(anytype _value)
    {
        Object valueObject = _value;

        return valueObject;
    }

    /// <summary>
    /// Explicitly converts an object of any type to .NET <c>System.Object</c> class.
    /// </summary>
    /// <param name="_value">
    /// The value to convert.
    /// </param>
    /// <returns>
    /// The .net object representation of the value.
    /// </returns>
    public static System.Object any2DotNetObject(anytype _value)
    {
        System.Object valueObject = _value;

        return valueObject;
    }

    static AOSClientMode aosClientMode()
    {
        return classfactory.aosClientMode();
    }

    /// <summary>
    /// Converts number to roman numeral.
    /// </summary>
    /// <param name="_arabic">
    /// Number to convert.
    /// </param>
    /// <returns>
    /// Roman number if convertable.
    /// </returns>
    /// <remarks>
    /// There is no definite rule for converting to roman numerals about 2000 and above.
    /// Numbers starting from 4000 require vinculum letters, so are not supported.
    /// </remarks>
    static public str arabic2Roman(int _arabic)
    {
        container   arabicCon = [ 1,   5,   10,  50,  100, 500, 1000 ];
        container   romanCon  = [ 'I', 'V', 'X', 'L', 'C', 'D', 'M'  ];

        str         roman;
        int         i, j;
        int         remainder;

        if (_arabic <= 0 || _arabic > 3999)
        {
            return '';
        }

        while (_arabic >= conPeek(arabicCon, i+1) &&
               i+1 <= conLen(arabicCon))
        {
            i++;
        }

        remainder = _arabic mod conPeek(arabicCon, i);

        if (i > 1 ? remainder div conPeek(arabicCon, i-1) > 3 : false)
        {
            roman = conPeek(romanCon, i-1) + conPeek(romanCon, i+1);

            if (strLen(int2str(_arabic)) >= 1)
            {
                roman += arabic2Roman(_arabic - conPeek(arabicCon, i+1) + conPeek(arabicCon, i-1));
            }
        }

        else
        {
            if (_arabic div conPeek(arabicCon, i) > 3)
            {
                roman = conPeek(romanCon, i) + conPeek(romanCon, i+1);
            }
            else
            {
                for (j = 1; j <= _arabic div conPeek(arabicCon, i); j++)
                {
                    roman += conPeek(romanCon, i);
                }
            }
            if (strLen(int2str(_arabic)) >= 1)
            {
                roman += arabic2Roman(remainder);
            }
        }

        return roman;
    }

    static CryptoBlob binary2cryptoblob(Binary _binary, int _binaryLength)
    {
        if (_binary && _binaryLength > 0)
        {
            CryptoBlob cryptoBlob;

            for (int i = 0; i < _binaryLength; i++)
            {
                cryptoBlob += [_binary.byte(i)];
            }

            return cryptoBlob;
        }
        else
        {
            return conNull();
        }
    }

    static int bitReset(int _flags, int _reset)
    {
        return _flags & ~_reset;
    }

    static int bitSet(int _flags, int _set)
    {
        return _flags | _set;
    }

    static boolean bitTest(int _flags, int _test)
    {
        return (_flags & _test) != 0;
    }

    static void buf2Buf(
		Common  _from,
		Common  _to,
		TableScope _scope = TableScope::CurrentTableOnly)
    {
        var dictTable = new DictTable(_from.TableId);
        FieldId fieldId = dictTable.fieldNext(0, _scope);

        while (fieldId && ! isSysId(fieldId))
        {
            _to.(fieldId)   = _from.(fieldId);
            fieldId         = dictTable.fieldNext(fieldId, _scope);
        }
    }

    /// <summary>
    /// Converts a record into a container.
    /// </summary>
    /// <param name="_common">Record to be converted.</param>
    /// <param name="_packOrigBuffer">true if the original table buffer must be included as part of the container, false otherwise.</param>
    /// <returns>A container with the table buffers of a record.</returns>
    static container buf2Con(Common _common, boolean _packOrigBuffer =  false)
    {
        return _common.buf2con(_packOrigBuffer);
    }

    static boolean bufCmp(Common b1,Common b2)
    {
        return b1.equal(b2);
    }

    static char charMax()
    {
        char charMax = classfactory.globalCache().get(funcName(),0,'');

        if (!charMax)
        {
            charMax = appl.charMax();
            classfactory.globalCache().set(funcName(),0,charMax, false);
        }

        return charMax;
    }

    static boolean checkFailed(SysInfoLogStr txt, URL helpURL = '', SysInfoAction _sysInfoAction = null)
    {
        infolog.add(Exception::Warning, getPrefix()+txt, helpURL, _sysInfoAction, false, infolog.resolveContextLabelId(txt));
        return false;
    }

    /// <summary>
    ///    Checks that the specified percentage value is between zero and 100.
    /// </summary>
    /// <param name="_value">
    ///    The percentage value to check.
    /// </param>
    /// <returns>
    ///    true if the value is between zero and 100; otherwise, false.
    /// </returns>
    static boolean checkPercentage(real _value)
    {
        if (_value < 0 || _value > 100)
        {
            return checkFailed("@SYS113615");
        }

        return true;
    }

    private static container checkPower(int64  _test, int64 _power, GenderMaleFemale _gender, boolean _isMexican)
    {
        int64   numOfPower, auxnumOfPower;
        int64   temp;
        real    test = any2real(_test);
        str     strText, returntxt, cPstr;
        int     intStrText;
        int64   cPint;
        real    temptest;   // to support ES-MX billions
        real    tempauxtest;
        real    auxtest = 0;
        real    numOfTenths ;
        
        str 20  ones[19], twenties[9], tenths[9],  muchhundreds, hundreds, thousands, muchmillions, millions, billions, muchhunmillions, trillions, muchtrillions;
        
        #Define.text_1_male('Un')
        #Define.text_1_female('Una')
        #Define.text_2('Dos')
        #Define.text_3('Tres')
        #Define.text_4('Cuatro')
        #Define.text_5('Cinco')
        #Define.text_6('Seis')
        #Define.text_7('Siete')
        #Define.text_8('Ocho')
        #Define.text_9('Nueve')
        #Define.text_10('Diez')
        #Define.text_11('Once')
        #Define.text_12('Doce')
        #Define.text_13('Trece')
        #Define.text_14('Catorce')
        #Define.text_15('Quince')
        #Define.text_16('Dieciseis')
        #Define.text_17('Diecisiete')
        #Define.text_18('Dieciocho')
        #Define.text_19('Diecinueve')
        
        #Define.text_20('Veinte')
        
        #Define.text_21_female('Veintiuna')
        #Define.text_21_male('Veintiun')
        #Define.text_22('Veintidos')
        #Define.text_23('Veintitres')
        #Define.text_24('Veinticuatro')
        #Define.text_25('Veinticinco')
        #Define.text_26('Veintiseis')
        #Define.text_27('Veintisiete')
        #Define.text_28('Veintiocho')
        #Define.text_29('Veintinueve')
        
        #Define.text_30('Treinta')
        #Define.text_40('Cuarenta')
        #Define.text_50('Cincuenta')
        #Define.text_60('Sesenta')
        #Define.text_70('Setenta')
        #Define.text_80('Ochenta')
        #Define.text_90('Noventa')
        
        #Define.text_100('Cien')
        #Define.text_100_female('cientas')
        #Define.text_100_male('cientos')
        #Define.text_100_much('Cientos')
        #Define.text_100_begin('Ciento')
        
        #Define.text_500_female('Quinientas')
        #Define.text_500_male('Quinientos')
        
        #Define.text_7_begin('Sete')
        #Define.text_9_begin('Nove')
        
        #Define.text_1000('Mil')
        
        #Define.text_1000000('Millon')
        #Define.text_1000000_much('Millones')
        #Define.text_1000000000('Mil millones')
        #Define.text_1000000000000('Trillón')
        #Define.text_1000000000000_much('Trillónes')
        
        #Define.text_and('y')
        
        ones[1] = #text_1_male;
        ones[2] = #text_2;
        ones[3] = #text_3;
        ones[4] = #text_4;
        ones[5] = #text_5;
        ones[6] = #text_6;
        ones[7] = #text_7;
        ones[8] = #text_8;
        ones[9] = #text_9;
        ones[10] = #text_10;
        ones[11] = #text_11;
        ones[12] = #text_12;
        ones[13] = #text_13;
        ones[14] = #text_14;
        ones[15] = #text_15;
        ones[16] = #text_16;
        ones[17] = #text_17;
        ones[18] = #text_18;
        ones[19] = #text_19;
        
        twenties[1] = _gender == GenderMaleFemale::Female ? #text_21_female: #text_21_male;
        twenties[2] = #text_22;
        twenties[3] = #text_23;
        twenties[4] = #text_24;
        twenties[5] = #text_25;
        twenties[6] = #text_26;
        twenties[7] = #text_27;
        twenties[8] = #text_28;
        twenties[9] = #text_29;
        
        tenths[1] = ''; // Not used
        tenths[2] = #text_20;
        tenths[3] = #text_30;
        tenths[4] = #text_40;
        tenths[5] = #text_50;
        tenths[6] = #text_60;
        tenths[7] = #text_70;
        tenths[8] = #text_80;
        tenths[9] = #text_90;
        
        hundreds    = #text_100;
        
        muchhundreds = _gender == GenderMaleFemale::Female ? #text_100_female: #text_100_male;
        
        muchhunmillions = #text_100_much;
        
        thousands   = #text_1000;
        millions    = #text_1000000;
        muchmillions = #text_1000000_much;
        
        billions    = #text_1000000000;
        trillions   = #text_1000000000000;
        muchtrillions = #text_1000000000000_much;
        
        
        if (_test >= _power)
        {
            numOfPower = _test div _power;
            if (numOfPower >= 100)
            {
                temp = numOfPower div 100;
                if (temp == 1 )
                {
                    if  (((_power == 1000) && (numOfPower > 100)) || ((_power == 1000000) && (numOfPower > 100)))
                    {
                        returntxt = returntxt + ' ' +  #text_100_begin;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' +  hundreds;
                    }
                }
                else
                {
                    switch(temp)
                    {
                        case 5:
                            if (_power == 1000)
                            {
                                returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_500_female : #text_500_male);
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + #text_500_male;
                            }
                            break;
                        
                        case 7:
                            if ( _power == 1000)
                            {
                                returntxt = returntxt + ' ' +  #text_7_begin + muchhundreds;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' +  #text_7_begin + muchhunmillions;
                            }
                            break;
                        
                        case 9:
                            if ( _power == 1000)
                            {
                                returntxt = returntxt + ' ' +  #text_9_begin + muchhundreds;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' +  #text_9_begin + muchhunmillions;
                            }
                            break;
                        
                        default:
                            if ( _power == 1000 )
                            {
                                returntxt = returntxt + ' ' + ones[temp] + muchhundreds;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + ones[temp] + muchhunmillions;
                            }
                        
                    }
                }
                numOfPower = numOfPower mod 100;
            }
            
            if (numOfPower >= 20)
            {
                temp = numOfPower div 10;
                if (numOfPower > 20 && numOfPower < 30)
                {
                    if ( ( numOfPower == 21 ) & ( _power == 1000000 ) )
                    {
                        returntxt = returntxt + ' ' + #text_21_male;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + twenties[numOfPower-20];
                    }
                }
                else
                {
                    returntxt = returntxt + ' ' + tenths[temp];
                }
                
                auxnumOfPower = numOfPower;
                numOfPower = numOfPower mod 10;
            }
            
            if ((numOfPower >= 1 ) && !(auxnumOfPower > 20 && auxnumOfPower < 30))
            {
                if (!(( (numOfPower == 5) || (numOfPower == 1) || (numOfPower == 7) || (numOfPower == 9) ) && (_power == 100)))
                {
                    if  ((( _power == 1000 ) && ( test > 10000 )) || (( _power == 1000000 ) && ( test > 10000000 )))
                    {
                        strText = subStr(strLTrim(num2str(test,15,0,1,0)),2,2);
                        intStrText = str2int(strText);
                        
                        if   (((_power == 1000) & ( intStrText >= 1 ) & (intStrText  < 20) & (intStrText  != 10) &
                                (intStrText  != 11)) || ((_power == 1000000) & (intStrText >= 1 ) & (intStrText < 20)))
                        {
                            if (( numOfPower < 20 ) & ( auxnumOfPower < 30 ))
                            {
                                returntxt = returntxt + ' ' + ones[numOfPower];
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfPower];
                            }
                        }
                        else
                        {
                            if (( numOfPower < 20 ) & ( auxnumOfPower < 30 ))
                            {
                                returntxt = returntxt + ' ' + ones[numOfPower];
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfPower];
                            }
                        }
                    }
                    else
                    {
                        if (!((numOfPower == 1) && (_power == 1000)))
                        {
                            returntxt = returntxt + ' ' + ones[numOfPower];
                        }
                        else if ((numOfPower == 1) && (_power == 1000) && _isMexican)
                        {
                            returntxt = returntxt + ' ' + ones[numOfPower];
                        }
                    }
                }
                numOfPower = numOfPower mod 10;
                
            }
            
            auxnumOfPower = 0;
            switch(_power)
            {
                case 1000000000000:
                    if (( _test >= 1000000000000) && ( _test < 2000000000000))
                    {
                        returntxt = returntxt + ' ' + trillions;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + muchtrillions;
                    }
                    _test = _test mod 1000000000000;
                    break;
                
                case 1000000000:
                    if (_isMexican)
                    {
                        // Save test variables
                        temptest = test;
                        tempauxtest = auxtest;
                        
                        // Reset returntxt as it is corrected below
                        returntxt = '';
                        
                        // Get billions + millions portion
                        test = str2num(int642str(_test div 1000000));
                        
                        [cPint, cPstr] = checkPower(any2int64(test), 1000, _gender, _isMexican);
                        test = str2num(int642str(cPint));
                        if(cPstr)
                        {
                            returntxt = returntxt + ' ' + cPstr;
                        }
                        
                        [cPint, cPstr] = checkPower(any2int64(test), 100, _gender, _isMexican);
                        test = str2num(int642str(cPint));
                        if(cPstr)
                        {
                            returntxt = returntxt + ' ' + cPstr;
                        }
                        
                        if (test >= 20)
                        {
                            numOfTenths = real2int(test) div 10;
                            if (test > 20 && test < 30)
                            {
                                returntxt = returntxt + ' ' + twenties[test - 20];
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + tenths[numofTenths];
                            }
                            numOfTenths = real2int(numOfTenths) mod 10;
                            auxtest = test;
                            test = real2int(test) mod 10;
                        }
                        
                        if ((test >= 1) && !(auxtest > 20 && auxtest < 30))
                        {
                            numOfTenths = test;
                            if (numOfTenths == 1)
                            {
                                if (auxtest == 0)
                                {
                                    returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
                                }
                                else
                                {
                                    returntxt = returntxt + ' ' + #text_and + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
                                }
                            }
                            else
                            {
                                if (( auxtest > 20 ))
                                {
                                    returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfTenths];
                                }
                                else
                                {
                                    returntxt = returntxt + ' ' + ones[numOfTenths];
                                }
                            }
                        }
                        
                        // Reset test variables
                        test = temptest;
                        auxtest = tempauxtest;
                        
                        if (_test >= 1000000 && _test < 2000000)
                        {
                            returntxt = returntxt + ' ' + millions;
                        }
                        else
                        {
                            returntxt = returntxt + ' ' + muchmillions;
                        }
                        _test = _test mod 1000000;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + billions;
                        _test = _test mod 1000000000;
                    }
                    break;
                
                case 1000000:
                    if (( _test >= 1000000) && ( _test < 2000000))
                    {
                        returntxt = returntxt + ' ' + millions;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + muchmillions;
                    }
                    _test = _test mod 1000000;
                    break;
                
                case 1000:
                    returntxt = returntxt + ' ' + thousands;
                    _test = _test mod 1000;
                    break;
                
                case 100:
                    if ((_test >= 100) && (_test < 200))
                    {
                        if (_test == 100)
                        {
                            returntxt = returntxt + ' ' + hundreds;
                        }
                        else
                        {
                            returntxt = returntxt + ' ' + #text_100_begin;
                        }
                    }
                    else
                    {
                        if (_test >= 500 && _test < 600)
                        {
                            returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_500_female : #text_500_male);
                        }
                        else if (_test >= 700 && _test < 800)
                        {
                            returntxt = returntxt + ' ' + #text_7_begin + muchhundreds;
                        }
                        else if (_test >= 900 && _test < 1000)
                        {
                            returntxt = returntxt + ' ' + #text_9_begin + muchhundreds;
                        }
                        else
                        {
                            returntxt = returntxt  + muchhundreds;
                        }
                    }
                    
                    _test = _test mod 100;
                    break;
            }
        }
        return [_test, strLTrim(returntxt)];
    }

    static boolean checkSign(str s)
    {
        int len = strLen(s);

        boolean check(char sign)
        {
            int pos     = strScan(s,sign,1,len);
            int posE    = strScan(s,'e',1,len);

            if (! pos)
                return true;

            // If sign not the first and not the last or if a exp. char then not after this
            if (pos != 1 &&
               ((! pose && pos != len) ||
                (pose && pos < pose)
               ))
                return false;

            // Test for multiple -
            s = strRem(s,sign);
            if (strLen(s) != len && strLen(s)+1 != len)
                return false;

            return true;
        }

        if (! check('-'))
        {
            return false;
        }

        if (! check('+'))
        {
            return false;
        }

        return true;
    }

    static boolean checkTime(Seconds timeSec)
    {
        if (timeSec < 0 || timeSec > 24*60*60)
        {
            return checkFailed("@SYS25363");
        }

        return true;
    }

    static ClassName classId2Name(ClassId _classId)
    {
        var dictClass = new DictClass(_classId);

        if (dictClass)
        {
            return dictClass.name();
        }

        return '';
    }

    static int className2Id(IdentifierName _className)
    {
        return dict.className2Id(_className);
    }

    static ClientType clientKind()
    {
        SysGlobalCache  cache = classfactory.globalCache();
        ClientType      clientType;
        xSession        session;

        if (cache.isSet(classStr(Global), funcName()))
        {
            clientType = cache.get(classStr(Global), funcName(), ClientType::Client);
        }
        else
        {
            session    = new xSession();
            clientType = session.clientKind();
            cache.set(classStr(Global), funcName(), clientType, false);
        }

        return clientType;
    }

    static AOSClientMode clientmode()
    {
        var session = new Session();
        var aosSession = new AOSSessionInfo(session.sessionId());

        if (aosSession)
        {
            return aosSession.clientMode();
        }

        return AOSClientMode::NotAOS;
    }

    /// <summary>
    /// Creates the non-deep copy of the Map.
    /// </summary>
    /// <param name="_mapToClone">
    /// The map instance to clone.
    /// </param>
    /// <returns>
    /// The non-deep copy of the map passed in the <paramref name="_mapToClone" /> parameter.
    /// </returns>
    /// <remarks>
    /// This method creates a new instance of the map that contains the same element instances as the
    /// source map.
    /// </remarks>
    public static Map cloneMap(Map _mapToClone)
    {
        if (!_mapToClone)
        {
            return null;
        }

        var newMap = new Map(_mapToClone.keyType(), _mapToClone.valueType());
        var mapEnumerator = new MapEnumerator(_mapToClone);

        while(mapEnumerator.moveNext())
        {
            newMap.insert(mapEnumerator.currentKey(), mapEnumerator.currentValue());
        }

        return newMap;
    }

    public static str clr2XppStr(System.String s1)
    {
        str s2;
        s2 = s1;
        return s2;
    }

    /// <summary>
    /// Converts a .NET <c>System.DateTime</c> object to an X++ <c>utcdatetime</c> value.
    /// </summary>
    /// <param name="_systemDateTime">
    /// The .NET <c>System.DateTime</c> object to convert.
    /// </param>
    /// <returns>
    /// An X++ <c>utcdatetime</c> value.
    /// </returns>
    static utcdatetime clrSystemDateTime2UtcDateTime(System.DateTime _systemDateTime)
    {
        return CLRInterop::getAnyTypeForObject(_systemDateTime);
    }

    /// <summary>
    /// Converts a container into a record.
    /// </summary>
    /// <param name="_container">
    /// Container to be converted
    /// </param>
    /// <param name="_rec">
    /// Optional record to which the container is converted, if specified,
    /// the conversion is only carried out if the record is the same concrete
    /// type of that in the container.
    /// </param>
    /// <returns>
    /// The record to which the container is converted. A new record will be
    /// created and returned if the optional record parameter is not specified or
    /// of a different concrete type from that in the container.
    /// </returns>
    static Common con2Buf(container _container,
                          Common    _rec = null)
    {
        Common    thisRec = null;
        TableId   tableId;
        DictTable dictTable;
        FieldId   fieldId;
        int       i;
        boolean   convert = false;

        if ( prmisDefault(_rec) )
        {
            if( conpeek(_container,1) is Common)
            {
                thisRec = conpeek(_container,1);
                return thisRec;
            }
            tableId   = conPeek(_container,1);
            dictTable = new DictTable(tableId);

            if (dictTable)
            {
                thisRec = dictTable.makeRecord();
                convert = true;
            }
        }
        else
        {
            thisRec = _rec;
        }

        Types conElementType = typeOf(conPeek(_container, conLen(_container)));

        if (conElementType == Types::Container || conElementType == Types::Record)
        {
            // delegate to kernel API
            thisRec.con2buf(_container);
        }
        else
        {
            // backward compatibility: unpack container packed with previous versions of AX
            tableId = conPeek(_container,1);
            dictTable = new DictTable(tableId);

            if (dictTable)
            {
                if (convert || tableName2id(_rec.getInstanceRelationType()) == tableId || _rec.TableId == tableId)
                {
                    fieldId = dictTable.fieldNext(0, TableScope::IncludeBaseTables);
                    i = 2;
                    while (fieldId)
                    {
                        thisRec.(fieldId) = conPeek(_container,i);
                        i++;
                        fieldId = dictTable.fieldNext(fieldId, TableScope::IncludeBaseTables);
                    }
                }
            }
        }

        return thisRec;
    }

    public static List con2List(container _con)
    {
        List list = null;
        int i;
        Types types;
        boolean typesIsOk = true;

        if (conLen(_con))
        {
            types = typeOf(conPeek(_con,1)); //Type of first element
        }

        for (i=2;i<=conLen(_con);i++)
        {
            if (typeOf(conPeek(_con,i)) != types)
                typesIsOk = false;
        }

        if (typesIsOk)
        {
            list = new List(types);

            for (i=1;i<=conLen(_con);i++)
            {
                list.addEnd(conPeek(_con,i));
            }
        }

        return list;
    }

    /// <summary>
    ///    Decodes a container from a base64 string.
    /// </summary>
    /// <param name="_stringValue">A string value.</param>
    /// <returns>A container.</returns>
    public static container base64str2con(str _stringValue)
    {
        return ContainerClass::blob2Container(BinData::loadFromBase64(_stringValue));
    }

    /// <summary>
    ///    Encodes a container to a base64 string.
    /// </summary>
    /// <param name="_container">The container to encode.</param>
    /// <returns>A string value.</returns>
    public static str con2base64str(container _container)
    {
        var containerClass = new ContainerClass(_container);
        BinData binData = new BinData();

        binData.setData(containerClass.toBlob());
        return binData.base64Encode();
    }

    static str con2Str(container c, str sep = ',')
    {
        int         idx = 0;
        int         len = conLen(c);
        str         tmp;
        str         retStr;

        while (idx < len)
        {
            idx += 1;
            if (retStr)
            {
                retStr += sep;
            }

            tmp = conPeek(c,idx);
            retStr += tmp;
        }
        return retStr;
    }

    static str con2StrUnlimited(container c, str 10 sep = ',')
    {
        int         idx = 0;
        int         len = conLen(c);
        str  100    tmp;
        str         retStr;

        while (idx < len)
        {
            idx += 1;
            if (retStr) 
            {
                retStr += sep;
            }

            tmp = conPeek(c,idx);
            retStr += tmp;
        }

        return retStr;
    }

    static ConfigurationKeyName configurationkeyId2Name(ConfigurationKeyId _configurationKeyId)
    {
        var dictConfigurationKey = new DictConfigurationKey(_configurationKeyId);

        if (dictConfigurationKey)
        {
            return dictConfigurationKey.name();
        }

        return '';
    }

    static str configurationkeyId2pName(ConfigurationKeyId _configurationKeyId)
    {
        var dictConfigurationKey = new DictConfigurationKey(_configurationKeyId);

        if (dictConfigurationKey)
        {
            return dictConfigurationKey.label();
        }

        return '';
    }

    static ConfigurationKeyId configurationKeyName2Id(IdentifierName _name)
    {
        return dict.configurationKeyName2Id(_name);
    }

    /// <summary>
    ///    Reverses the root elements of a container and then adds them into a new container.
    /// </summary>
    /// <param name="_originalContainer">
    ///    A container with root elements.
    /// </param>
    /// <returns>
    ///    A new container with the root elements in a reversed order.
    /// </returns>
    public static container conReverse(container _originalContainer)
    {
        container   reversedContainer = conNull();
        int         i;

        for (i=conLen(_originalContainer); i>0; i--)
        {
            reversedContainer += [conPeek(_originalContainer, i)];
        }

        return reversedContainer;
    }

    /// <summary>
    /// Converts an EDT array to a container.
    /// </summary>
    /// <param name = "_edtArray">The array to convert.</param>
    /// <returns>The container value.</returns>
    public static container extendedTypeArrayToContainer(anytype _edtArray)
    {
        var valuePeekObject = _edtArray as Microsoft.Dynamics.Ax.Xpp.AxShared.IEdtArray;
        int length = valuePeekObject.Size;
        container retValue = connull();

        for (int arrayIter = 1; arrayIter <= length; arrayIter++)
        {
            anytype valueIndex = valuePeekObject.Get_Item(arrayIter, null);
            retValue += [valueIndex];
        }

        return retValue;
    }

    /// <summary>
    /// Converts an container to an EDT array.
    /// </summary>
    /// <param name = "_container">The container to convert.</param>
    /// <param name = "_baseValueType">The type of elements to convert.</param>
    /// <returns>The array value.</returns>
    public static anytype container2ExtendedTypeArray(container _container, Types _baseValueType)
    {
        Microsoft.Dynamics.Ax.Xpp.AxShared.IEdtArray valuePeekObject;

        switch (_baseValueType)
        {
            case Types::String:
            case Types::RString:
            case Types::VarString:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.String>();
                break;
            case Types::Container:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Object>();
                break;
            case Types::UserType:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Object>();
                break;
            case Types::Record:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<Microsoft.Dynamics.Ax.Xpp.Common>();
                break;
            case Types::Real:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Decimal>();
                break;
            case Types::Date:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<Microsoft.Dynamics.Ax.Xpp.AxShared.Date>();
                break;
            case Types::Time:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<int>();
                break;
            case Types::UtcDateTime:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<Microsoft.Dynamics.Ax.Xpp.AxShared.utcdatetime>();
                break;
            case Types::AnyType:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Object>();
                break;
            case Types::void:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Object>();
                break;
            case Types::Integer:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Int32>();
                break;
            case Types::Int64:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Int64>();
                break;
            case Types::Enum:                
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Int32>();
                break;
            case Types::Guid:
                valuePeekObject = new Microsoft.Dynamics.Ax.Xpp.EdtArray<System.Guid>();
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcname()));
                break;
        }

        for (int i = 1; i <= conlen(_container); i++)
        {
            valuePeekObject.Set_Item(i, null, conpeek(_container, i));
        }

        anytype returnValue = valuePeekObject;
        return returnValue;
    }

    // The node is <container> ... </container>
    static container containerFromXMLNode(XmlNode n)
    {
        container retval, containerToInsert;
        Common recordToInsert;
        XmlNamedNodeMap attrs;
        XmlNode typeAttr, packVersionAttr, appVersionAttr, element, recordNode, containerNode;
        str packVersion, appVersion;
        int elemNo = 1;

        //validate arguments before using them
        if (n == null)
        {
            return retval;
        }

        if (extendedSerialization)
        {
            attrs = n.attributes();
            packVersionAttr = attrs.getNamedItem('packVersion');
            packVersion = packVersionAttr.nodeValue();
            appVersionAttr = attrs.getNamedItem('appVersion');
            appVersion = appVersionAttr.nodeValue();
        }

        // Collect all the elements ...
        element = n.firstChild();
        while (element)
        {
            attrs = element.attributes();
            typeAttr = attrs.getNamedItem('type');

            switch (typeAttr.nodeValue())
            {
                case 'array'    :
                    var baseTypeAttr = attrs.getNamedItem('baseType');
                    str arraySubtype = baseTypeAttr.nodeValue();
                    container subElements = connull();
                    subElements = containerFromXMLNode(element.firstChild());
                    retval = conIns(retval, elemNo, container2ExtendedTypeArray(subElements, xmlGetTypeFromSpelling(arraySubtype)));
                    break;
                case 'enum'     : 
                    if (extendedSerialization)
                    {
                        var enumTypeAttrib   = attrs.getNamedItem('enumtype');
                        var enumSymbolAttrib = attrs.getNamedItem('enumsymbol');
                        if (enumTypeAttrib && enumSymbolAttrib)
                        {
                            str enumType   = enumTypeAttrib.Text();
                            str enumSymbol = enumSymbolAttrib.text();

                            if (enumType == #CSBoolean)
                            {
                                retval = conIns(retval, elemNo, enumSymbol == 'true'? true : false);
                                break;
                            }
                            else
                            {
                                SysDictEnum dictEnum = new SysDictEnum(enumName2Id(enumType));
                                if (dictEnum)
                                {
                                    int enumActualValue = dictEnum.symbol2Value(enumSymbol);
                                    retval = conIns(retval, elemNo, enumActualValue);
                                    break;
                                }
                            }
                        }
                    }
                    // else fall through.
                case 'int'      :
                    retval = conIns(retval, elemNo, str2int(getXmlNodeValue(element)));
                    break;

                case 'int64'    :
                    retval = conIns(retval, elemNo, str2int64(getXmlNodeValue(element)));
                    break;

                case 'guid'      :
                    retval = conIns(retval, elemNo, str2Guid(getXmlNodeValue(element)));
                    break;

                case 'str'      :
                    retval = conIns(retval, elemNo, getXmlNodeValue(element));
                    break;

                case 'real'     :
                    retval = conIns(retval, elemNo, str2num(getXmlNodeValue(element)));
                    break;

                case 'date'     :
                    retval = conIns(retval, elemNo, str2Date(getXmlNodeValue(element), 321));
                    break;

                case 'time'     :
                    retval = conIns(retval, elemNo, str2Time(getXmlNodeValue(element)));
                    break;

                case 'datetime' :
                case 'utcdatetime' :
                    retval = conIns(retval, elemNo, str2datetime(getXmlNodeValue(element), DateFlags::None));
                    break;

                case 'record'   :
                    recordNode = element.firstChild();
                    recordToInsert = recordFromXMLNode(recordNode);                    
                    if (extendedSerialization)
                    {
                        var namedItem = attrs.getNamedItem('id');
                        if (namedItem)
                        {
                            recordToInsert.RecId = str2Int64(namedItem.Text());
                        }
                    }
                    retval = conIns(retval, elemNo, recordToInsert);
                    break;

                case 'container':
                    containerNode = element.firstChild();
                    containerToInsert = containerFromXMLNode(containerNode);
                    retval = conIns(retval, elemNo, containerToInsert);
                    break;

                case 'blob':
                    containerToInsert = BinData::stringToData(getXmlNodeValue(element));
                    boolean nestUnderContainer = true;

                    if (extendedSerialization)
                    {
                        var nestedAttr = attrs.getNamedItem('nested');
                        str nested = (nestedAttr != null)? nestedAttr.nodeValue() : "";
                        nestUnderContainer = (nested == "true");
                    }

                    if (!nestUnderContainer)
                    {
                        // to support XML serialization of binary data, remove the wrapper
                        System.Object[] dataBuffer = containerToInsert;
                        anytype dataBufferXpp = dataBuffer.GetValue(0);
                        retval = conIns(retval, elemNo, dataBufferXpp);
                    }
                    else
                    {
                        retval = conIns(retval, elemNo, containerToInsert);
                    }

                    break;
                    
                case 'unknown'      :
                    
                    if (extendedSerialization)
                    {
                        // reserve a space in the container allocation chain
                        retval = conIns(retval, elemNo, null);
                        break;
                    }
                    // else fall through

                default:
                    if (extendedSerialization)
                    {
                        retval = conIns(retval, elemNo, null);
                    }
                    ApplicationPlatformTelemetry::LogEventMarker(ApplicationPlatformTelemetryLevel::Error, classStr(Global), funcName(), 'Value Deserialization', strFmt('Type \'%1\' was skipped when deserializing XML', typeAttr.nodeValue()));
                    break;
            }

            element = element.nextSibling();
            elemNo += 1;
        }

        return retval;
    }

    /// <summary>
    /// Calculates the contribution ratio, which is based on the sales price and the purchase price.
    /// </summary>
    /// <param name="sale">The sale price. The sale price must be greater than 0.</param>
    /// <param name="purchase">The purchase price.</param>
    /// <returns>The contribution ratio.</returns>
    static real contributionRatio(real sale, real purchase)
    {
        return dg(sale,purchase);
    }

    /// <summary>
    /// Checks whether the specified flighting name is enabled.
    /// </summary>
    /// <param name = "_flightName">The flighting name to evaluate.</param>
    /// <returns>true if the flighting feature is enabled.</returns>
    public static boolean isFlightEnabled(SysFlightName _flightName)
    {
        if (!appl)
        {
            logMissingAppl(funcName(), strFmt('Flight \'%1\' could not be checked. False (default) was returned.', _flightName));
            return false;
        }

        return  appl.isInTransactionScope()? SysTestFlightingManager::isFlightEnabled(_flightName) :  SysFlightingService::isFeatureEnabled(_flightName);
    }

    /// <summary>
    /// Checks whether the specified flighting is enabled.
    /// </summary>
    /// <param name = "_flightName">The flighting feature Name to evaluate.</param>
    /// <param name = "_context">The context of this flighting feature.</param>
    /// <returns>true if the flighting feature is enabled.</returns>
    public static boolean isFeatureEnabledWithContext(SysFlightName _flightName, Map _context)
    {
        if (!appl)
        {
            logMissingAppl(funcName(), strFmt('Flight \'%1\' could not be checked. False (default) was returned.', _flightName));
            return false;
        }

        return appl.isInTransactionScope()? SysTestFlightingManager::isFlightEnabledWithContext(_flightName, _context) :  SysFlightingService::isFeatureEnabledWithContext(_flightName, _context);
    }

    private static void logMissingAppl(MethodName _invokedMethodName, str _message)
    {
        ApplicationPlatformTelemetry::LogEventMarker(ApplicationPlatformTelemetryLevel::Warning, classStr(Global), _invokedMethodName, 'Missing appl instance', _message);
    }

    /// <summary>
    /// Gets if the current environment is an on premise host environment.
    /// </summary>
    /// <returns>True, if the current environment is an on premise environment; otherwise, False.</returns>
    public static boolean isOnPremEnvironment()
    {
        return deploymentType() == DeploymentType::OnPrem;
    }

    /// <summary>
    /// Gets the deployment type of the environment.
    /// </summary>
    /// <returns>The deployment type of the environment.</returns>
    public static DeploymentType deploymentType()
    {
        const str deploymentTypeKey = "DeploymentType";

        DeploymentType deploymentType = DeploymentType::Unknown;
        SysGlobalCache globalCache = classfactory.globalCache();

        try
        {
            // Read from global cache first.
            if(globalCache.isSet(funcname(), deploymentTypeKey))
            {
                deploymentType = globalCache.get(funcname(), deploymentTypeKey);
            }
            else
            {
                var environment = EnvironmentFactory::GetApplicationEnvironment();
                if(environment)
                {
                    // Update global cache.
                    deploymentType = environment.Common.DeploymentType;
                    globalCache.set(funcname(), deploymentTypeKey, deploymentType);
                }
            }
        }
        catch (Exception::CLRError)
        {
            deploymentType = DeploymentType::Unknown;
        }

        return deploymentType;
    }

    /// <summary>
    ///    Creates a container with the union of the elements of two containers.
    /// </summary>
    /// <param name="_container1">
    ///    An input container.
    /// </param>
    /// <param name="_container2">
    ///    An input container.
    /// </param>
    /// <returns>
    ///    A new container with the union of the elements of the input containers.
    /// </returns>
    /// <remarks>
    ///    Input containers are assumed to have no repeated elements within themselves.
    ///    If the first container has repeated elements they will be kept repeated in the union.
    /// </remarks>
    public static container conUnion(container _container1, container _container2)
    {
        container   union = conNull();
        int         i;
        int         container2length;

        union = _container1;

        container2length = conLen(_container2);
        for(i=1; i<=container2length; i++)
        {
            if (!conFind(_container1, conPeek(_container2, i)))
            {
                union += [conPeek(_container2, i)];
            }
        }

        return union;
    }

    static Array createArrayFromXML(XmlNode node)
    {
        XmlElement el;
        Types type;
        Array retval;

        if (node && node.nodeType() == XmlNodeType::Element)
        {
            el = node;
            type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
            if (type != Types::void)
            {
                retval = new Array(type);
                loadArrayFromXML(node, retval);
            }
        }

        return retval;
    }

    static List createListFromXML(XmlNode node)
    {
        XmlElement el;
        Types type;
        List retval;

        if (node && node.nodeType() == XmlNodeType::Element)
        {
            el = node;
            type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
            if (type != Types::void)
            {
                retval = new List(type);
                loadListFromXML(node, retval);
            }
        }

        return retval;
    }

    static Map createMapFromXML(XmlNode node)
    {
        XmlElement el;
        Types keytype;
        Types valuetype;
        Map retval;

        if (node && node.nodeType() == XmlNodeType::Element)
        {
            el = node;

            keytype = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_KEY_TYPE));
            valuetype = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_VALUE_TYPE));

            if (
                (keytype != Types::void) &&
                (valuetype != Types::void))
            {
                retval = new Map(keytype, valuetype);
                loadMapFromXML(node, retval);
            }
        }

        return retval;
    }

    static Set createSetFromXML(XmlNode node)
    {
        XmlElement el;
        Types type;
        Set retval;

        if (node && node.nodeType() == XmlNodeType::Element)
        {
            el = node;
            type = xmlGetTypeFromSpelling(el.getAttribute(#ATTR_TYPE));
            if (type != Types::void)
            {
                retval = new Set(type);
                loadSetFromXML(node, retval);
            }
        }

        return retval;
    }

    static Struct createStructFromXML(XmlNode node)
    {
        XmlElement el;
        Struct retval;

        if (node && node.nodeType() == XmlNodeType::Element)
        {
            el = node;
            retval = new Struct(el.getAttribute(#ATTR_TYPE));
            loadStructFromXML(node, retval);
        }

        return retval;
    }

    static Binary cryptoblob2binary(CryptoBlob _cryptoBlob)
    {
        if (_cryptoBlob == conNull())
        {
            return null;
        }

        int cryptoLen = conLen(_cryptoBlob);
        Binary b;
        int i;

        if ((cryptoLen mod 2) == 1)
        {
            _cryptoBlob += [0];
            cryptoLen += 1;
        }
 
        try
        {
            // Add null terminated if cryptoblob does not have
            if (System.Convert::ToInt32(conPeek(_cryptoBlob, cryptoLen-1)) == 0
                && System.Convert::ToInt32(conPeek(_cryptoBlob, cryptoLen)) == 0)
            {
                b = new Binary(cryptoLen);
            }
            else
            {
                b = new Binary(cryptoLen + 2);
                b.byte(cryptoLen, 0);
                b.byte(cryptoLen + 1, 0);
            }

            for (i = 0; i < cryptoLen; i++)
            {
                var value = conPeek(_cryptoBlob, i + 1);
                if (i < (cryptoLen - 3) && System.Convert::ToInt32(value) == 0
                    && System.Convert::ToInt32(conPeek(_cryptoBlob, i + 2)) == 0)
                {
                    throw Error('Cannot contain null in the middle of cryptoblob.');
                }

                b.byte(i, value);
            }
        }
        catch (Exception::CLRError)
        {
            CLRObject e = CLRInterop::getLastException();
            SystemRuntimeEventSource::EventWriteSecurityGenericException('cryptoblob2binary',
                e.ToString());
            throw;
        }
        return b;
    }

    static str cryptoblob2str(CryptoBlob _cryptoBlob)
    {
        Binary b;

        if (_cryptoBlob != conNull())
        {
            b = cryptoblob2binary(_cryptoBlob);
            return b.wString(0);
        }
        else
            return '';
    }

    static DataAreaId curExt2dataareaid(TableId _tableId)
    {
        DictTable   dictTable = new DictTable(_tableId);
        Common      common;

        if (!dictTable)
            return '';

        common = dictTable.makeRecord();
        return common.DataAreaId;
    }

    /// <summary>
    ///     Gets the guid representing the current user.
    /// </summary>
    /// <returns>
    ///     A guid value.
    /// </returns>
    public static guid curUserGuid()
    {
        return xGlobal::curUserGuid();
    }

    /// <summary>
    ///     Gets the guid representing the specified user.
    /// </summary>
    /// <param name="_userId">
    ///     The ID of the user.
    /// </param>
    /// <returns>
    ///     A guid value.
    /// </returns>
    public static guid getUserGuid(UserId _userId)
    {
        return new xSession().getUserGuid(_userId);
    }

    //To be used instead of infolog.currentAOLayer() to avoid c/s calls.
    static UtilEntryLevel currentAOLayer()
    {
        SysGlobalCache  cache   = classfactory.globalCache();
        UtilEntryLevel  value;

        if (cache.isSet(classStr(Global), funcName()))
        {
            value = cache.get(classStr(Global), funcName());
            return value;
        }
        value = infolog.currentAOLayer();
        cache.set(classStr(Global), funcName(), value, false);
        return value;
    }

    static boolean currentSessionLanguageRTL()
    {
        return isLanguageRTL(infolog.language());
    }

    static LanguageId currentUserLanguage()
    {
        UserInfo userInfo;

        select Language from userInfo
            where userInfo.Id == curUserId();

        LanguageId languageID = userInfo.Language;
        userInfo.dispose();

        return languageID;
    }

    static boolean currentUserLanguageRTL()
    {
        UserInfo userInfo;
        select Language from userInfo
            where userInfo.Id == curUserId();

        LanguageId languageID = userInfo.Language;
        userInfo.dispose();

        return isLanguageRTL(languageID);
    }

    /// <summary>
    /// convert date to Japanese Era date
    /// </summary>
    /// <param name="_date">
    /// The Gregorian date value
    /// </param>
    /// <param name="_strfmt">
    /// The Japanese Era date format value; optional.
    /// </param>
    /// <returns>
    /// Japanese Era date
    /// </returns>
    // <GJP>
    public static str date2JapaneseEra_JP(date _date, str _strfmt = #DateFormat_ggYMD)
    {
        #define.CultureName('ja-JP')
        System.Globalization.CultureInfo        cultureInfo;
        System.Globalization.DateTimeFormatInfo myDateTimeInfo;
        System.Globalization.JapaneseCalendar   japaneseCal;
        System.DateTime                         myDateTimeObj;
        str                                     myresult;
        InteropPermission                       clrPermission;

        try
        {
            clrPermission = new InteropPermission(InteropKind::ClrInterop);
            clrPermission.assert();

            // BP deviation documented
            cultureInfo = new System.Globalization.CultureInfo(#CultureName, false);

            // BP deviation documented
            japaneseCal    = new System.Globalization.JapaneseCalendar();
            myDateTimeInfo = cultureInfo.get_DateTimeFormat();
            myDateTimeInfo.set_Calendar(japaneseCal);

            // BP deviation documented
            myDateTimeObj = new System.DateTime(year(_date), mthOfYr(_date), dayOfMth(_date));
            myresult      = myDateTimeObj.ToString(_strfmt, cultureInfo);

            return myresult;
        }
        catch (Exception::CLRError)
        {
            return '';
        }
    }

    // </GJP>

    //  Converts any valid date to a string value that represents it's Julian date.
    static str date2Julian(date _enteredDate)
    {
        #define.defaultJulian('0000000')

        int             numberOfDays;
        str 7           julianDate = #defaultJulian;

        if (_enteredDate >= dateNull() && _enteredDate <= dateMax())
        {
            numberOfDays = (date2num(_enteredDate) - date2num(mkDate(1,1,year(_enteredDate))) + 1);
            julianDate = int2str(year(_enteredDate)) + num2Str0(numberOfDays, 3);
        }

        return julianDate;
    }

    static int  date2Qtr(date transDate)
    {
        return ((mthOfYr(transDate)-1) div 3 + 1);
    }

    public static TempStr date2StrUsr(date transDate , int flags = DateFlags::None)
    {
        return date2str(transDate,-1,-1,-1,-1,-1,-1, flags);
    }

    /*
    Returns a date as a string in the x++ code format, also used in formulas in queries:
    dd\mm\yyyy
    */
    static str 10 date2StrXpp(date _date)
    {
        //    return strReplace(date2str(_date,123,2,4,2,4,4),'/','\\');
        return num2Str0(dayOfMth(_date),2)+
               '\\'+
               num2Str0(mthOfYr(_date),2)+
              '\\'+
               num2Str0(year(_date),4);
    }

    static date dateEndMth(date transDate)
    {
        if (transDate >= dateMax())
            return transDate;
        return dateStartMth(dateMthFwd(transDate, 1)) - 1;
    }

    static date  dateEndQtr(date transDate)
    {
        if (mthOfYr(transDate) mod 3 == 1)
        {
            transDate= nextMth(transDate);
        }

        if (mthOfYr(transDate) mod 3 == 2)
        {
            transDate= nextMth(transDate);
        }

        return endmth(transDate);
    }

    /// <summary>
    ///    Returns the date of the end of the week. The first day of the week is determined by the
    ///    <c>firstDayOfWeek</c> function, which is locale-aware.
    /// </summary>
    /// <param name="transDate">
    ///    The date for which the end of the week date information is desired.
    /// </param>
    /// <returns>
    ///    Date of the end of the week.
    /// </returns>
    /// <remarks>
    ///    If the week starts on Sunday, the end of the week will be next Saturday. Similarly, if the week
    ///    starts on Monday the end of the week will be next Sunday The logic below can be implied into a
    ///    single if else block, but might be difficult to follow.
    /// </remarks>
    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getEndOfWeekDate method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static date  dateEndWk(date transDate)
    {
        date dateEndOfWeek;
        int firstDay;
        int dayOfWeek;
        int daysToAdd;

        // firstDayOfWeek returns a number 0 to 6, Monday = 0 and Sunday = 6
        firstDay = firstDayOfWeek();
        // dayofwk returns a number 1 to 7, Monday = 1 and Sunday = 7
        dayOfWeek = dayOfWk(transdate);
        if (firstDay > 0)
        {
            if (firstDay > (dayOfWeek - 1))
            {
                daysToAdd = firstday - dayOfWeek;
            }
            else
            {
                daysToAdd = 7 - (dayOfWeek - firstDay) ;
            }
        }
        else
        {
            daysToAdd = 7 - dayOfWeek;
        }

        dateEndOfWeek = transDate + daysToAdd;

        return dateEndOfWeek;

    }

    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getEndOfYearDate method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static date dateEndYr(date transDate)
    {
        if (year (transDate) == year (maxDate()))
            return maxDate();
        return dateStartYr(nextYr(transDate)) - 1;
    }

    static date dateMax()
    {
        return maxDate();
    }

    static date  dateMthFwd(date transDate,
                            int  qty)
    {
        int     day     = dayOfMth(transDate);
        int     month   = mthOfYr( transDate);
        int     yr      = year(    transDate);

        month = month + qty;

        while (month > 12)
        {
            yr++;
            month = month - 12;
        }

        while (month <= 0)
        {
            yr--;
            month = month + 12;
        }

        return mkDate(day,month,yr);
    }

    static date dateNull()
    {
        return 01\01\1900;
    }

    static date dateStartMth(date transDate)
    {
        int daysToSubTract = dayOfMth(transDate) -1;
        return transDate - daysToSubTract;
    }

    static date dateStartQtr(date transDate)
    {
        if (mthOfYr(transDate) mod 3 == 0)
        {
            transDate= prevMth(transDate);
        }

        if (mthOfYr(transDate) mod 3 == 2)
        {
            transDate= prevMth(transDate);
        }

        return dateStartMth(transDate);
    }

    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getStartOfWeekDate method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static date dateStartWk(date transDate)
    {
        // firstDayOfWeek returns a number 0 to 6, Monday = 0 and Sunday = 6
        int firstDay = firstDayOfWeek();

        // dayofwk returns a number 1 to 7, Monday = 1 and Sunday = 7
        int dayOfWeek = dayOfWk(transdate);

        int daysToSubtract = dayOfWeek - 1 >= firstDay ? (dayOfWeek - 1 - firstDay) : (dayOfWeek + 6 - firstDay);

        return transDate - daysToSubtract;
    }

    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getStartOfYearDate method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static date dateStartYr(date transDate)
    {
        int daysToSubtract = dayOfYr(transDate) -1;
        return transDate - daysToSubtract;
    }

    static utcdatetime datetobeginUtcDateTime(date currDate, Timezone tz)
    {
        return DateTimeUtil::newDateTime(currDate, 0, tz);
    }

    static public anytype defaultValue_RU(Types _type)
    {
        switch (_type)
        {
            case Types::AnyType,
                 Types::Integer,
                 Types::Int64,
                 Types::Enum        :
                 return 0;

            case Types::Real        :
                return 0.00;

            case Types::String,
                 Types::RString     :
                 return '';

            case Types::Date        :
                 return dateNull();

            case Types::Container   :
                 return conNull();

            case Types::Class,
                 Types::Record :
                 return null;

            case Types::Guid:
                 return emptyGuid();

            case Types::UtcDateTime:
                 return utcDateTimeNull();
        }

        return 0;
    }

    static utcdatetime datetoendUtcDateTime(date currDate, Timezone tz)
    {
        #timeConstants;
        return DateTimeUtil::newDateTime(currDate, #secondsPerDay-1, tz);
    }

    static void deleteTable(TableName tableName, boolean concreteTypeOnly = false, boolean skipAosValidation = false)
    {
        Dictionary  dictionary          = dict;
        int         tableHandle         = dictionary.tableName2Id(tableName);
        Common      anyRecord;
        Common      common;

        if (! dictionary.tableSql(tableHandle))
        {
            return;
        }

        var dictTable = new DictTable(tableHandle);

        if (dictTable.isMap() || dictTable.isTmp())
        {
            return;
        }

        dictTable   = new DictTable(tableHandle);
        anyRecord   = dictTable.makeRecord();

        common = dictTable.makeRecord();

        if (skipAosValidation)
        {
            //BP Deviation documented
            common.skipAosValidation(true);
        }

        ttsbegin;

        common.skipDeleteMethod(true);
        common.skipDeleteActions(true);

        if (concreteTypeOnly && dictTable.supportInheritance())
        {
            delete_from common
                where common.RelationType == 0;
        }
        else
        {
            delete_from common;
        }

        ttscommit;

        if (dictTable.cacheLookup() == RecordCacheLevel::EntireTable)
        {
            Dictionary::dataFlush(dictTable.id());
        }
    }

    /// <summary>
    /// Calculates the depreciation of an asset over a specified period.
    /// </summary>
    /// <param name="price">
    /// The purchase price of the asset.
    /// </param>
    /// <param name="scrap">
    /// The scrap value of the asset.
    /// </param>
    /// <param name="life">
    /// The expected life of the asset (the number of periods).
    /// </param>
    /// <param name="period">
    /// The period for which to calculate depreciation.
    /// </param>
    /// <returns>
    /// The amount of depreciation over the specified period.
    /// </returns>
    /// <remarks>
    /// Unlike the <c>Global.straightLineDepreciation</c> method, this method can use accelerated
    /// depreciation of the asset. As with the <c>Global.acceleratedDepreciation</c> method, an accelerated
    /// depreciation enables more depreciation during the early periods in the life of an asset.This method
    /// is a rename of the <c>syd</c> method.
    /// </remarks>
    static real depreciation(real price, real scrap, real life, int period)
    {
        return syd(price, scrap, life, period);
    }

    static void dictionaryFlush()
    {
        Dictionary dictionary = dict;

        dictionary.enumFlush();
        dictionary.typeFlush();
        dictionary.tableFlush();
        dictionary.classFlush();
    }

    static Common dynaKey2Record(str keystr,int tableid = 0, boolean selectforUpdate = false, boolean allowCrossCompany = false)
    {
        QueryRun qrun;
        QueryBuildDataSource qB;
        Query q;
        str 300 fstr;
        int i;
        int fieldid;
        Common record;

        // The keystr is encoded in the URL as this:
        // [fieldid:strvalue][fieldid2:strvalue]

        if (! keystr)
            return null;

        q = new Query();
        if(allowCrossCompany)
        {
            q.allowCrossCompany(true);
        }
        qB = q.addDataSource(tableid);
        qB.update(selectforUpdate);

        while (keystr)
        {
            i = strFind(keystr,']',1,999);
            if (i)
            {
                fstr = subStr(keystr,2,i-2);
                keystr = subStr(keystr,i+1,999);
            }

            if (! fstr)
            {
                return null;
            }

            i = strFind(fstr,':',1,999);
            fieldid = real2int(str2num(subStr(fstr,1,i-1)));

            qB.addRange(fieldid).value(queryValue(subStr(fstr,i+1,999)));
        }
        qrun = new QueryRun(q);

        qrun.next();

        record = qrun.get(tableid);

        return record;

    }

    /// <summary>
    ///    Creates a guid with this value: {0000000-0000-0000-0000-000000000000}.
    /// </summary>
    /// <returns>
    ///    A guid with this value: {0000000-0000-0000-0000-000000000000}.
    /// </returns>
    static guid emptyGuid()
    {
        return nullValueFromType(Types::Guid);
    }

    /// <summary>
    /// Enable or disable the specified field in the data source.
    /// </summary>
    /// <param name="_dataField">
    /// The form datasource field to enable.
    /// </param>
    /// <param name="_enable">
    /// A Boolean value indicating whether the field should be enabled.
    /// </param>
    public static void enableDatasourceFieldObject(FormDataObject _dataField, boolean _enable)
    {
        if (_dataField != null)
        {
            _dataField.allowEdit(_enable);
            _dataField.skip(!_enable);
        }
    }

    /// <summary>
    /// Enable or disable the specified field in the data source.
    /// </summary>
    /// <param name="_datasource">
    /// The form datasource to enable the fields for.
    /// </param>
    /// <param name="_fieldId">
    /// The ID of the field to enable or disable.
    /// </param>
    /// <param name="_enable">
    /// A Boolean value indicating whether the field should be enabled.
    /// </param>
    /// <remarks>
    /// This is a convenience method to enable or disable and assign the skip property for a field in the
    /// associated data source. The field id must be valid for the table in referenced
    /// by this data source.
    /// When the field is disabled for input then the skip attribute will be enabled.
    /// </remarks>
    public static void enableDSField(FormDataSource _datasource, FieldId _fieldId, boolean _enable)
    {
        if (_datasource && _fieldId)
        {
            enableDatasourceFieldObject(_datasource.object(_fieldId), _enable);
        }
    }

    [SysObsoleteAttribute('endLengthyOperation is deprecated and no longer needed. You can safely remove calls to this method', true, 27\11\2014)]
    #obsolete static void endLengthyOperation(boolean endALL = false)
    {
        /*
        EndLengthyOperation is called from Infolog.onEventGoingIdle.
        This saves the potential client/server calls below.
        */
    }

    static int enum2int(anytype e)
    {
        return e;
    }

    static str enum2Symbol(EnumId _id, int _val)
    {
        DictEnum de = new DictEnum(_id);

        return de.value2Symbol(_val);
    }

    static str enum2Value(anytype E)
    {
        str     test;
        Types   t = typeOf(E);
        int     len;

        if (t != Types::Enum)
            throw error(strFmt("@SYS23815",funcName()));

        test    = strFmt('%1',E);
        len     = strLen(test);
        if (strFind(test,',!',1,len) || strScan(test,'..',1,len) || len == 0)
            return int2str(E);
        return test;
    }

    static IdentifierName enumId2Name(int id)
    {
        DictEnum dictEnum = new DictEnum(id);
        if (dictEnum)
            return dictEnum.name();
        return '';
    }

    /// <summary>
    /// Returns the label of the enumeration.
    /// </summary>
    /// <param name="_id">
    /// Enumeration Id
    /// </param>
    /// <returns>
    /// The label of the enumeration
    /// </returns>
    static IdentifierName enumId2pname(int _id)
    {
        DictEnum dictEnum = new DictEnum(_id);

        if (dictEnum)
        {
            return dictEnum.label();
        }

        return '';
    }

    /*
        Returns the first enum entry which is enabled. If non is enabled 0 is returned.
        */
    static anytype enumInit(EnumId id)
    {
        DictEnum dictEnum = new DictEnum(id);
        int      i;

        if (dictEnum)
        {
            for (i=0; i<dictEnum.values(); i++)
            {
                if (isConfigurationkeyEnabled(dictEnum.value2ConfigurationKey(i)))
                {
                    return i;
                }
            }
        }
        return 0;
    }

    static int enumName2Id(IdentifierName enumname)
    {
        return dict.enumName2Id(enumname);
    }

    static Exception error(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
    {
        //    Box::stop(getprefix()+txt,"","");
        //    return Exception::Error;
        return infolog.add(Exception::Error, getPrefix()+txt, helpUrl, _sysInfoAction, false, infolog.resolveContextLabelId(txt));
    }

    /*
        Call this method to acknowledge the text in the exception should fallthrough
        and eventually be caught by the infolog.

        Example:

        try
        {

        }
        catch
        {
        ExceptionTextFallThrough();
        }

        */
    public static void exceptionTextFallThrough()
    {
        ;
    }

    static boolean existLayer(UtilEntryLevel _layer, boolean _old = false)
    {
        UtilFile utilFile = new UtilFile(_old ? 'old' : 'aod');
        str      layers   = utilFile.layers();

        return strScan(layers, enum2str(_layer), 1, strLen(layers)) != 0;
    }

    /*
        Returns the display type name of a given type
        */
    static str extendedTypeId2DisplayName(Types _type, int _typeId)
    {
        switch (_type)
        {
            case Types::String:
            case Types::RString:
            case Types::VarString:
                return 'str';
            case Types::Container:
                return 'container';
            case Types::Class:
                return classId2Name(_typeId) ? classId2Name(_typeId) : classStr(Object);
            case Types::UserType:
                return extendedTypeId2name(_typeId);
            case Types::Record:
                return tableId2name(_typeId);
            case Types::Real:
                return 'real';
            case Types::Date:
                return 'date';
            case Types::Time:
                return 'time';
            case Types::UtcDateTime:
                return 'utcdatetime';
            case Types::AnyType:
                return 'anytype';
            case Types::void:
                return 'void';
            case Types::Integer:
                return 'int';
            case Types::Int64:
                return 'int64';
            case Types::Enum:
                return enumId2Name(_typeId);
            case Types::Guid:
                return 'guid';
        }
        return '';
    }

    /*
        Returns the name of an extended type
        */
    static IdentifierName extendedTypeId2name(ExtendedTypeId id)
    {
        DictType dictType = new DictType(id);

        if (dictType)
            return dictType.name();

        return '';
    }

    /*
        Returns the label of an extended type
        */
    static IdentifierName extendedTypeId2pname(ExtendedTypeId id)
    {
        DictType dictType = new DictType(id);

        if (dictType)
            return dictType.label();

        return '';
    }

    static Types extendedTypeId2Type(ExtendedTypeId _id)
    {
        DictType d = new DictType(_id);

        //validate arguments before using them
        if (d == null)
            return Types::AnyType;

        return d.baseType();
    }

    /// <summary>
    ///    Converts an extended data type name to its ID.
    /// </summary>
    /// <param name="_typename">
    ///    The name of the extended data type.
    /// </param>
    /// <returns>
    ///    The ID of the extended data type.
    /// </returns>
    static public ExtendedTypeId extendedTypeName2Id(ExtendedDataTypeName  _typename)
    {
        return dict.typeName2Id(_typename);
    }

    static int factorial(int _n)
    {
        if (_n > 1)
            return _n * factorial(_n - 1);
        else
            return 1;
    }

    /*
        Returns the fieldId part of an extended FieldId
        (an extended FieldId is a fieldId including the array index)
        */
    static FieldId fieldExt2Id(FieldId fieldExtId)
    {
        return (fieldExtId & 0xffff);
    }

    /*
        Returns the Array index part of an extended FieldId
        (an extended FieldId is a fieldId including the array index)
        */
    static int fieldExt2Idx(FieldId fieldExtId)
    {
        return (fieldExtId >> 16);
    }

    /*
        Returns an extended FieldId, based on the fieldId and the Array index
        (an extended FieldId is a fieldId including the array index)
        */
    static FieldId fieldId2Ext(FieldId  fieldId,
                               ArrayIdx arrayIndex
                               )
    {
        return ((arrayIndex << 16) | fieldId);
    }

    /// <summary>
    /// Returns a help text for the field, specified by table Id and field Id.
    /// </summary>
    /// <param name="_tableId">
    /// Table Id.
    /// </param>
    /// <param name="_fieldId">
    /// Field Id.
    /// </param>
    /// <param name="_arrayEntry">
    /// Field array index.
    /// </param>
    /// <returns>
    /// Help text for the field.
    /// </returns>
    static public str fieldId2Help(
        TableId _tableId,
        FieldId _fieldId,
        int     _arrayEntry = 1)
    {
        DictField dictField = new DictField(_tableId, _fieldId);

        if (dictField)
            return dictField.help(_arrayEntry);

        return '';
    }

    static str fieldLabelValue(TableId t_TableId, FieldId f_FieldId, anytype _value)
    {
        DictField dictField = new DictField(t_TableId, f_FieldId);

        //validate arguments before using them
        if (dictField == null)
            return "";
        else
            return strFmt('%1: %2',dictField.label(), _value);
    }

    static Filename fileNameNext(Filename _filename)
    {
        int             i;
        Filename        filename;
        FilenameType    filenameType;
        str             filePath;

        [filePath, filename, filenameType] = fileNameSplit(_filename);

        while (System.IO.File::Exists(_filename))
        {
            i++;
            _filename =  filePath + filename + ' (' + int2str(i) + ')' + filenameType;
        }

        return _filename;
    }

    static container fileNameSplit(Filename _filename)
    {
        #define.foreslash('/')
        #define.colon(':')
        #define.dot('.')
        #file

        int         foundPath;
        int         foundType;
        Filename    filepath;
        Filename    fileExt;

        if (_filename)
        {
            foundPath  = strFind(_filename, #FilePathDelimiter, strLen(_filename), -strLen(_filename));
            if (!foundPath)
            {
                foundPath  = strFind(_filename, #foreslash, strLen(_filename), -strLen(_filename));

                if (!foundPath)
                {
                    foundPath  = strFind(_filename, #colon, strLen(_filename), -strLen(_filename));
                }
            }
            if (foundPath)
            {
                filepath  = subStr(_filename, foundPath, -foundPath);
                _filename = strDel(_filename, foundPath, -foundPath);
            }

            foundType = strFind(_filename, #dot, strLen(_filename), -strLen(_filename));
            if (foundType)
            {
                fileExt   = subStr(_filename, foundType, strLen(_filename)-foundType+1);
                _filename = strDel(_filename, foundType, strLen(_filename)-foundType+1);
            }
        }
        return [filepath, _filename, fileExt];
    }

    static Filename fileNameTrim(Filename _filename)
    {
        Filename    path;
        Filename    name;
        Filename    extention;

        [path, name, extention] = fileNameSplit(_filename);

        if (!name)
        {
            return '';
        }

        return path + name + extention;
    }

    static public QueryBuildRange findOrCreateRange_W(QueryBuildDataSource _dataSource, FieldId _fieldId, Range _value = '')
    {
        QueryBuildRange ret = xSysQuery::findOrCreateRange(_dataSource, _fieldId);

        if (! prmisDefault(_value))
        {
            ret.value(_value);
        }

        return ret;
    }

    /// <summary>
    /// Finds the most restricted range status among all the queries that are applied on the given field
    /// </summary>
    public static RangeStatus getMostRestrictedStatus(Query query, QueryBuildDataSource qbs, FieldName fieldName, int arrayIndex = 1, boolean checkQueryFilters = true)
    {
        RangeStatus     rangeStatus = RangeStatus::Open;
        RangeStatus     filterStatus = RangeStatus::Open;
        RangeStatus     mostRestrictedStatus = RangeStatus::Open;
    
        FieldId fieldId = fieldName2id(qbs.table(), fieldName);
        FieldId extendedFieldId = fieldId2Ext(fieldId, arrayIndex);
        if (checkQueryFilters)
        {
            filterStatus = query.getMostRestrictedQueryFilterStatus(qbs, "", extendedFieldId); // Use extended fieldId rather than fieldName to support arrayFields
        }

        rangeStatus = qbs.getMostRestrictedQueryBuildRangeStatus(fieldId, 1, arrayIndex);
        mostRestrictedStatus = (rangeStatus >= filterStatus) ? rangeStatus : filterStatus;

        return mostRestrictedStatus;
    }

    /* MAN
        returns the value of the property in the supplied property set.
        If the property does not exist an empty string is returned.
        */
    static str findProperty(str _properties, str _property)
    {
        int propertyPos = findPropertyPos(_properties,_property);
        int j;
        int k;
        str propertyValue;

        if (propertyPos)
        {
            j = strScan(_properties, '#', propertyPos, strLen(_properties)-propertyPos)+1;
            k = StrFind(_properties, System.Environment::NewLine, j, strLen(_properties)-j);
            propertyValue = subStr(_properties,j,k-j);
        }
        return propertyValue;
    }

    /* MAN
        returns the position (in characters) of the property identifier in the supplied property set.
        If the property does not exist, zero is returned.

        example of a property sheet:

        PROPERTIES
        Name                #CustPaymManTrans
        Title               #
        Form                #SysQueryForm
        UserUpdate          #Yes
        Version             #41
        Interactive         #Yes
        AllowCheck          #No
        ENDPROPERTIES

        DataSource          #
        DataField           #
        ExtendedDataType
        ARRAY
        #MarkUpAllocateAfterType
        #
        ENDARRAY
        ArrayIndex          #0
        DataMethod          #
        Border              #Auto

        */
    static int findPropertyPos(str _properties, str _property)
    {
        str propertyPattern = ' '+_property+' ';
        int propertyPos = strScan(_properties, propertyPattern, 1, strLen(_properties));

        // validate that it is a position of a property identifier
        if (propertyPos &&
            (match(propertyPattern+' *\\#',subStr(_properties,propertyPos,strLen(_properties))) ||
             match(propertyPattern+': *ARRAY: +\\#',subStr(_properties,propertyPos,strLen(_properties)))) ) // find the first entry in an arry property
        {
            propertyPos++;  // to compensate for the leading space in propertyPattern
            return propertyPos;
        }

        return 0;
    }

    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getFirstDayOfWeek method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static int firstDayOfWeek()
    {
        SysGlobalCache  cache   = classfactory.globalCache();
        int             clientFirstDayOfWeek;

        if (cache.isSet(classStr(Global), funcName()))
        {
            clientFirstDayOfWeek = cache.get(classStr(Global), funcName());
        }
        else
        {
            str language = currentUserLanguage();
            System.Globalization.CultureInfo userCulture = System.Globalization.CultureInfo::GetCultureInfo(language);
            System.Globalization.DateTimeFormatInfo fi = userCulture.get_DateTimeFormat();
            int dow = fi.get_FirstDayOfWeek();

            // The .NET API returns 0 for sunday, but we expect sunday to
            // be represented as 6, (monday is 0).
            clientFirstDayOfWeek = (dow + 6) mod 7;

            cache.set(classStr(Global), funcName(),clientFirstDayOfWeek);
        }

        return clientFirstDayOfWeek;
    }

    static FirstLine firstLine(str txt)
    {
        int i = strFind(txt,'\n',1,strLen(txt));

        return i ? subStr(txt,1,i-1) : txt;
    }

    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getFirstWeekOfYear method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static int firstWeekOfYear()
    {
        #WinAPI
        SysGlobalCache  cache   = classfactory.globalCache();
        int             clientFirstWeekOfYear;
        anytype         calendarWeekRuleValue;
        str             language;
        System.Globalization.CultureInfo        userCulture;
        System.Globalization.CalendarWeekRule   calendarWeekRule;
        System.Globalization.DateTimeFormatInfo userDateTimeFormat;

        if (cache.isSet(classStr(Global), funcName()))
        {
            clientFirstWeekOfYear = cache.get(classStr(Global), funcName());
        }
        else
        {
            language = currentUserLanguage();
            userCulture = new System.Globalization.CultureInfo(language);
            userDateTimeFormat = userCulture.get_DateTimeFormat();
            calendarWeekRule    = userDateTimeFormat.get_CalendarWeekRule();
            calendarWeekRuleValue = CLRInterop::getAnyTypeForObject(calendarWeekRule);

            switch(calendarWeekRuleValue)
            {
                case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstDay) :
                    clientFirstWeekOfYear = 0;
                    break;
                case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstFullWeek) :
                    clientFirstWeekOfYear = 1;
                    break;
                case CLRInterop::getAnyTypeForObject(System.Globalization.CalendarWeekRule::FirstFourDayWeek) :
                    clientFirstWeekOfYear = 2;
                    break;
            }

            cache.set(classStr(Global), funcName(),clientFirstWeekOfYear);
        }

        return clientFirstWeekOfYear;
    }

    /// <summary>
    /// Flushes the virtual company values from the global cache.
    /// </summary>
    static void flushVirtualCompanyCache()
    {
        classfactory.globalObjectCache().clear(#VIRTUALCOMPANYLIST);
        classfactory.globalObjectCache().clear(#ISVIRTUALCOMPANY);
    }

    static str formCaption(FormName formName)
    {
        Form form = new Form(formName);
        if (form && form.design())
        {
            return form.design().caption();
        }
        return '';
    }

    static anytype formControlValue(
        Object      ctrl,
        Types       baseType
        )
    {
        //validate arguments before using them
        if (ctrl == null)
            return null;
        switch (baseType)
        {
            case Types::String:
                    if (classIdGet(ctrl) == classNum(FormStringControl))
                    return ctrl.valueStr();
                else
                    return ctrl.text();
            case Types::VarString:
                return ctrl.text();
            case Types::Integer:
                return ctrl.value();
            case Types::Int64:
                return ctrl.value();
            case Types::Real:
                return ctrl.realValue();
            case Types::Date:
                return ctrl.dateValue();
            case Types::UtcDateTime:
                return ctrl.dateTimeValue();
            case Types::Time:
                return ctrl.value();
            case Types::Enum:
                    if (classIdGet(ctrl) == classNum(FormCheckBoxControl)       ||
                    classIdGet(ctrl) == classNum(FormBuildCheckBoxControl)
                   )
                    return ctrl.value();
                return ctrl.selection();
            case Types::Guid:
                return ctrl.value();
        }
        return null;
    }

    static Map formDataSourceArrayFieldExtObjects(FormDataSource    _formDataSource,
                                                  FieldId           _fieldId)
    {
        Map         mapFieldObjects;
        DictField   dictField;
        FieldId     extFieldId;
        Counter     x;

        //validate arguments before using them
        if (_formDataSource == null)
            return null;
        mapFieldObjects = new Map (Types::Integer, Types::Class);

        dictField = new DictField(_formDataSource.table(), _fieldId);

        for (x = 1; x <= dictField.arraySize(); x++)
        {
            extFieldId = fieldId2Ext(_fieldId, x);

            mapFieldObjects.insert(extFieldId, _formDataSource.object(extFieldId));
        }

        return mapFieldObjects;
    }

    static boolean formDataSourceHasMethod(FormDataSource  _formDataSource,
                                                  IdentifierName  _methodName)
    {
        //validate arguments before using them
        if (_formDataSource == null)
            return false;
        return Form::formObjectSetHasMethod(_formDataSource, _methodName);
    }

    static void formDataSourceRefresh(Common _common)
    {
        FormObjectSet formObjectSet;
        if (FormDataUtil::getFormDataSource(_common))
        {
            formObjectSet = FormDataUtil::getFormDataSource(_common);
            formObjectSet.refresh();
        }
    }

    /// <summary>
    /// Get the FormRun object that owns a specific control.
    /// </summary>
    /// <param name="_control" type="FormControl">
    /// The form control to get the owner of
    /// </param>
    /// <returns type="FormRun">
    /// FormRun object instance that owns the given control, otherwise null.
    /// </returns>
    public static FormRun formGetFromControl(FormControl _control)
    {
        FormRun fr = null;

        if (_control != null)
        {
            fr = _control.formRun();
        }

        return fr;
    }

    /// <summary>
    ///    Retrieves an instance of the <c>FormDataSource</c> object which is a parent data source to the
    ///    specified <c>formDataSource</c> object.
    /// </summary>
    /// <param name="_formDataSource">
    ///    An instance of the <c>FormDataSource</c> object for which a parent is retrieved.
    /// </param>
    /// <param name="_includeSearchInQueries">
    ///    A Boolean value that indicates whether the search for a parent is performed also in the underlying
    ///    query of the specified instance of the <c>formDataSource</c> object.
    /// </param>
    /// <returns>
    ///    A <c>FormDataSource</c> object that is a parent data source if one can be found; otherwise, null.
    /// </returns>
    /// <remarks>
    ///    The default value for the <paramref name="_includeSearchInQueries" /> parameter is false. If the
    ///    specified <c>formDataSource</c> object is from a list page, it will typically be set to true.
    /// </remarks>
    static FormDataSource formGetParentDatasource(
        FormDataSource  _formDataSource,
        boolean         _includeSearchInQueries = false)
    {
        Counter                 i;
        QueryBuildDataSource    qbdsChild;
        QueryBuildDataSource    qbdsParent;
        Query                   query;
        FormRun                 formRun;
        FormDataSource          formDataSourceParent;
        int                     formRunNrOfDataSources;

        boolean isParentLinkedToChild(FormDataSource _formDataSourceParent, QueryBuildDataSource _qbdsChild)
        {
            Query                   queryParent;
            QueryBuildDataSource    qbsdParentLocal;
            int                     childCounter;

            //we got a datasource that could be the parent, but we examine that the parent also has the correct child
            queryParent = _formDataSourceParent.query();

            if (!queryParent)
            {
                return false;
            }

            if (!queryParent.childDataSourceCount())
            {
                return false;
            }

            qbsdParentLocal = queryParent.childDataSourceNo(1);//for modeled queries the parent is first child

            if (!qbsdParentLocal)
            {
                return false;
            }

            for (childCounter = 1; childCounter <= qbsdParentLocal.childDataSourceCount();childCounter++)
            {
                if (qbsdParentLocal.childDataSourceNo(childCounter).id() == _qbdsChild.id())
                {
                    return true;
                }
            }

            return false;
        }


        if (!_formDataSource)
        {
            return null;
        }

        if (!_includeSearchInQueries && !_formDataSource.joinSource())
        {
            return null;
        }

        formRun                 = _formDataSource.formRun();
        formRunNrOfDataSources  = formRun.dataSourceCount();

        for (i=1; i<= formRunNrOfDataSources; i++)
        {
            if (formRun.dataSource(i).id() == _formDataSource.joinSource())
            {
                return formRun.dataSource(i);
            }
        }

        if (!_includeSearchInQueries || _formDataSource.joinSource())
        {
            return null;
        }

        //For modeled queries used in list pages the method joinSource() returns 0 so we need to examine the underlying queries to find a parent formdatasource
        query = _formDataSource.query();

        if (!query)
        {
            return null;
        }

        qbdsChild = query.dataSourceTable(_formDataSource.table());

        if (!qbdsChild || !qbdsChild.linkCount())
        {
            return null;
        }

        qbdsParent = qbdsChild.parentDataSource();//queryBuildDataSource must be linked in order to call parentDataSource()

        if (!qbdsParent)
        {
            return null;
        }

        //try and find a matching parent
        for (i=1; i<=formRunNrOfDataSources; i++)
        {
            formDataSourceParent = formRun.dataSource(i);
            //examine the datasource to see if it is really linked to the child
            if (formDataSourceParent.table() == qbdsParent.table() && isParentLinkedToChild(formDataSourceParent,qbdsChild))
            {
                return formDataSourceParent;
            }
        }

        return null;
    }

    /// <summary>
    ///    Gets whether an xpp object has the specified method.
    /// </summary>
    /// <param name="_instance">
    ///    The object to check.
    /// </param>
    /// <param name="_methodName">
    ///    The name of the method.
    /// </param>
    /// <returns>
    ///    True if the method exists.
    /// </returns>
    public static boolean objectHasMethod(
        Object _instance, MethodName _methodName)
    {
        int classId = classIdGet(_instance);
        if (classId)
        {
            var sysDictClass = new SysDictClass(classId);
            return sysDictClass.hasObjectMethod(_methodName); 
        }
        return false;
    }

    /// <summary>
    ///    Gets whether an xpp form object has the specified method.
    /// </summary>
    /// <param name="fr">
    ///    The form instance to check.
    /// </param>
    /// <param name="methodName">
    ///    The name of the method.
    /// </param>
    /// <returns>
    ///    True if the method exists.
    /// </returns>
    public static boolean formHasMethod(
        FormRun        fr,
        IdentifierName methodName
        )
    {
        //validate arguments before using them
        if (fr == null)
            return false;
        return SysFormRun::hasMethod(fr,methodName);
    }

    static str formName2Pname(FormName formName)
    {
        MenuFunction mf;
        try
        {
            mf = new MenuFunction(formName, MenuItemType::Display);
        }
        catch(Exception::Internal)
        {
            mf = null;
        }

        if (mf)
        {
            if (mf.label())
                return mf.label();
        }

        return formCaption(formName);
    }

    /// <summary>
    /// Calculates the future value of an investment
    /// </summary>
    /// <param name="amount">
    /// The amount paid in during each period.
    /// </param>
    /// <param name="interest">
    /// The interest rate.
    /// </param>
    /// <param name="life">
    /// The number of investment periods.
    /// </param>
    /// <returns>
    /// The future value of the investment.
    /// </returns>
    /// <remarks>
    /// This method is a rename of the <c>fV</c> method.
    /// </remarks>
    static real futureValue(real amount, real interest, real life)
    {
        return fv(amount, interest, life);
    }

    /// <summary>
    /// Returns the company.
    /// </summary>
    /// <param name="tableID">
    /// A ID for a table.
    /// </param>
    /// <param name="_company">
    /// An ID of the company.
    /// </param>
    /// <returns>
    /// A Company.
    /// </returns>
    /// <remarks>
    /// This method has exposes the <c>xCompany::DataArea</c> method on the client tier for improved
    /// performance.
    /// </remarks>
    public static SelectableDataArea getCompany(int tableID, SelectableDataArea _company = "")
    {
        if (_company != "")
        {
            return xGlobal::company(tableId, _company);
        }
        return xGlobal::company(tableId);
    }

    /// <summary>
    /// Returns the <c>ActivityId</c> of the current thread.
    /// </summary>
    /// <returns>
    /// A guid.
    /// </returns>
    public static guid getCurrentThreadActivityId()
    {
        return System.Diagnostics.Tracing.EventSource::CurrentThreadActivityId;
    }

    /// <summary>
    /// Returns the browser session activity ID of the current thread, or an empty GUID if there isn't a request context.
    /// </summary>
    /// <returns>
    /// A guid.
    /// </returns>
    public static guid getCurrentThreadBrowserSessionActivityId()
    {
        guid id = emptyGuid();
        Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext context = Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext::Current;
        if (context && context.RequestContextInstance)
        {
            System.Guid::TryParse(context.RequestContextInstance.IncomingBrowserSessionActivityId, byref id);
        }
        return id;
    }

    static Common getFirstSelection(FormDataSource _formDataSource)
    {
        Common common = _formDataSource.getFirst(true);
        if (!common)
            common = _formDataSource.cursor();
        return common;
    }

    /// <summary>
    ///    Retrieves the joined child form data source for the specified form data source.
    /// </summary>
    /// <param name="_dataSource">
    ///    A form data source.
    /// </param>
    /// <param name="_childTableId">
    ///    An ID of the table of the joined form data source.
    /// </param>
    /// <param name="_occurence">
    ///    An occurrence of the table form data source.
    /// </param>
    /// <returns>
    ///    The joined child form data source.
    /// </returns>
    public static FormDataSource getJoinChildFormDataSource(FormDataSource _dataSource, TableId _childTableId, int _occurence = 1)
    {
        int             currentOccurence = 0;
        FormDataSource  formDataSource;
        FormRun         formRun;
        int             dataSourceCount;
        int             i;

        formRun             = _dataSource.formRun();
        dataSourceCount     = formRun.dataSourceCount();

        for (i = 1; i <= dataSourceCount; i++)
        {
            formDataSource  = formRun.dataSource(i);

            if     (formDataSource.joinSource() == _dataSource.id()
                &&  formDataSource.table()      == _childTableId)
            {
                currentOccurence++;
                if (currentOccurence == _occurence)
                {
                    return formDataSource;
                }
            }
        }

        if (currentOccurence == 0)
        {
            // for list page forms the data sources aren't marked as inner joins in meta data, so there is no joinSource
            for (i = 1; i <= dataSourceCount; i++)
            {
                formDataSource  = formRun.dataSource(i);

                if (formDataSource.table()      == _childTableId
                 && formDataSource.joinSource() == 0)
                {
                    currentOccurence++;
                    if (currentOccurence == _occurence)
                    {
                        return formDataSource;
                    }
                }
            }
        }

        return null;
    }

    static str getPrimaryKey(Common common)
    {
        DictTable dictTable = new DictTable(common.TableId);
        DictIndex dictIndex = new DictIndex(dictTable.id(), dictTable.indexUnique());
        FieldId fieldId;
        SysDictField sysDictField;
        str key,s;
        int i;

        for (i=1;i <= dictIndex.numberOfFields(); i++)
        {
            fieldId = dictIndex.field(i);
            sysDictField = new SysDictField(dictTable.id(), fieldId);
            switch (sysDictField.baseType())
            {
                case Types::Date:
                    s = date2str(common.(fieldId),-1,-1,-1,-1,-1,-1, DateFlags::None);
                    break;
                case Types::String:
                case Types::RString:
                case Types::VarString:
                    s =common.(fieldId);
                    break;
                case Types::UserType:
                        if (isTypeTime(sysDictField.typeName()))
                    {
                        s = time2str(common.(fieldId),-1,-1);
                    }
                default :
                    s = common.(fieldId);
            }
            key += (i==1?'':',')+s;
        }
        return key;
    }

    // gets substring from line separated with placeholders %<number>
    // Example:
    //   getSubString_W("abc %1 def %2 ghi", 2) returns " def "
    #define.PlaceholderSign("%")
    public static str getSubString_W(str _string, int _idx)
    {
        int startPos, endPos;
        str ret;

        if (_idx == 1)
        {
            startPos  = 1;
        }
        else
        {
            startPos  = strScan(_string, #PlaceholderSign + int2str(_idx - 1), 1, strLen(_string));
            startPos += startPos ? 2 : 0;
        }

        if (startPos)
        {
            endPos = strScan(_string, #PlaceholderSign + int2str(_idx), startPos, strLen(_string));

            if (! endPos)
            {
                endPos = strLen(_string) + 1;
            }

            ret = strRTrim(strLTrim(subStr(_string, startPos, endPos - startPos)));
        }

        return ret;
    }

    static str getXmlNodeValue(XmlNode _node)
    {
        System.Text.RegularExpressions.Regex re =
            // BP deviation documented
            new System.Text.RegularExpressions.Regex('^[ \r\n\t]*((.|\n)*?)[ \r\n\t]*$');
        System.Text.RegularExpressions.Match m = re.Match(_node.text());
        str result;

        result = m.Result('$1');
        return result;
    }

    /// <summary>
    ///    Calculates the greatest common divisor of two specified integers.
    /// </summary>
    /// <param name="_firstInteger">
    ///    The first integer.
    /// </param>
    /// <param name="_secondInteger">
    ///    The second integer.
    /// </param>
    /// <returns>
    ///    The greatest common divisor of two integers.
    /// </returns>
    public static int greatestCommonDivisor(int _firstInteger, int _secondInteger)
    {
        return (_secondInteger == 0) ? ((_firstInteger >= 0) ?  _firstInteger : -_firstInteger) : greatestCommonDivisor(_secondInteger, _firstInteger mod _secondInteger);
    }

    //BP Deviation Documented
    static guid guidFromString(str _value)
    {
        return str2guid(_value);
    }

    /// <summary>
    /// Remove the braces from guid
    /// </summary>
    /// <param name = "_guidValue">Guid thats generated in the system</param>
    /// <returns>The string of the guid without braces</returns>
    static str guid2StrWithoutBraces(guid _guidValue)
    {
        System.Guid guidWithBraces = _guidValue;
        str guidWithoutBraces;
        
        //Guid format D provides an guid with 32 digits seperated by hyphen without braces
        guidWithoutBraces = guidWithBraces.ToString('D').ToUpperInvariant();
        return guidWithoutBraces;
    }

    public static boolean hasFieldAccess(TableId _tableId, FieldId _fieldId, AccessType _neededAccessLevel = AccessType::View)
    {
        DictField dictField = new DictField(_tableId, _fieldId);

        if (dictField)
        {
            return dictField.rights() >= _neededAccessLevel;
        }
        return false;
    }

    public static boolean hasGUI()
    {
        return xGlobal::hasClient() && !isRunningOnBatch() && !isRunningSyncEngine();
    }

    static public boolean hasMenuItemAccess(MenuName name, MenuItemType type)
    {
        boolean     ret = false;
        SysDictMenu sysDictMenu = SysDictMenu::newMenuItem(name, type);

        if (sysDictMenu)
        {
            ret = sysDictMenu.isVisible();
        }

        return ret;
    }

    static boolean hasMenuItemSecurityAccess(MenuFunction _menu)
    {
        SysDictMenu sysDictMenu;

        if (_menu)
        {
            if (_menu.configurationKey())
            {
                if (!isConfigurationkeyEnabled(_menu.configurationKey()))
                    return false;
                if (!isConfigurationkeyEnabled(_menu.countryConfigurationkey()))
                    return false;
                if (!isConfigurationkeyEnabled(_menu.webConfigurationkey()))
                    return false;
            }

            if (!SysMetadataFeatureChecker::isFeatureEnabledForMenuFunction(_menu))
            {
                return false;
            }

            sysDictMenu = SysDictMenu::newMenuItem(_menu.name(), _menu.type());
            if (sysDictMenu)
            {
                return sysDictMenu.rights() >= _menu.neededAccessLevel();
            }
            return false;
        }
        return true;

    }

    /* MAN
        returns true if the supplied property identifier exist in the supplied property set.
        */
    static boolean hasProperty(str _properties, str _property)
    {
        if (findPropertyPos(_properties,_property))
        {
            return true;
        }
        return false;
    }

    public static boolean hasTableAccess(TableId _tableId, AccessType _neededAccessLevel = AccessType::View)
    {
        DictTable dictTable = new DictTable(_tableId);

        if (dictTable)
        {
            return dictTable.rights() >= _neededAccessLevel;
        }
        return false;
    }

    static int hex2Int(str 12 hex)
    {
        int res = 0;
        int d = strLen(hex);
        int i = 1;
        int char;

        int largeA = char2num('A',1);
        int largeF = char2num('F',1);
        int zero = char2num('0',1);
        int nine = char2num('9',1);

        hex = strUpr(hex);

        while (i <= d)
        {
            char = char2num(hex,i);

            res = res * 16;
            if ((char >= zero) && (char <= nine))
                res += (char - zero);
            else if ((char >= largeA) && (char <= largeF))
                res += (char - largeA + 10);
            else
                return 0;
            i++;
        }

        return res;
    }

    static Exception info(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
    {
        return infolog.add(Exception::Info, getPrefix()+txt, helpUrl, _sysInfoAction, false, infolog.resolveContextLabelId(txt));
    }

    /// <summary>
    /// Gets the number of lines in the Infolog buffer.
    /// </summary>
    /// <returns>
    /// The number of lines in the Infolog buffer.
    /// </returns>
    /// <remarks>
    /// This method has similar functionality to the <c>xInfo.line</c> method, but it improves performance
    /// and lowers network load when you are executing server-side code.When the <c>xInfo.line</c> method
    /// is run on the server, it makes a call to the client to retrieve the number of lines in the Infolog
    /// buffer. The <c>xGlobal::infologLine</c> method retrieves the server-side Infolog buffer line count.
    /// This eliminates the requirement to call to the client. When the <c>xGlobal::infologLine</c> method
    /// is called on the client, it returns the count directly from the Infolog buffer on the client.This
    /// method is especially useful when you write server-side code that processes exceptions.The number of
    /// lines in the Infolog is generally stored before entering a <c>try</c> / <c>catch</c> block.If an
    /// exception occurs, the number of lines that were previously stored is used to determine which
    /// messages were logged during the code in the <c>try</c> block. If no exceptions occur, the stored
    /// Infolog buffer line count is often unused. If you use the <c>xGlobal::infologLine</c> method
    /// instead of the <c>xInfo.line</c> method to retrieve the Infolog lines, a round-trip to the client
    /// is prevented.
    /// </remarks>
    public static int infologLine()
    {
        int line = 0;
        try
        {
            line = xGlobal::infologLine();
        }
        catch
        {
            line = 0;
        }
        return line;
    }

    static boolean inRange(str _rangeValue, anytype _value, boolean _checkNull = true)
    {
        TmpQueryRangeValue      t;
        Query                   q;
        QueryBuildDataSource    qbdS;
        QueryBuildRange         qbR;

        QueryRun qR;

        if (_checkNull)
            if (_value == nullValueBaseType(typeOf(_value), true))
                return false;

        q    = new Query();
        qbdS = q.addDataSource(t.TableId);

        switch (typeOf(_value))
        {
            case Types::Real:
                t.Real1 = _value;
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Real1));
                break;

            case Types::Integer:
                t.Int1 = _value;
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Int1));
                break;

            case Types::Date:
                t.Date1 = _value;
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Date1));
                break;

            case Types::String:
                t.Str1 = _value;
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Str1));
                break;

            case Types::Enum:
                t.Str1 = enum2str(_value);
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Str1));
                break;

            case Types::Int64:
                t.Int641 = any2int64(_value);
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Int641));
                break;

            case Types::Guid:
                t.Guid1 = any2guid(_value);
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,Guid1));
                break;

            case Types::UtcDateTime:
                t.Date1 = _value;
                qbR = qbdS.addRange(fieldNum(TmpQueryRangeValue,DateTime1));
                break;

            default:
                setPrefix(funcName());
                throw error(strFmt("@SYS26908",typeOf(_value)));
        }

        qbR.value(_rangeValue);

        t.insert();
        qR = new QueryRun(q);
        qR.setCursor(t);
        return qR.next();
    }

    #DEFINE.HEXDIGITS('0123456789ABCDEF')
    static str 12 int2Hex( int iValue, int digits = 0 )
    {
        int     i;
        int     iTemp;
        str 12  result = '';
        boolean isFirstTime = true;

        for (i=0;i<=7;i++)
        {
            iTemp = iValue & 0xf0000000u;
            iTemp = iTemp >> 28;
            iTemp = iTemp & 0x0000000f;

            if (isFirstTime && iTemp != 0)
            {
                isFirstTime = false;
            }
            if (!(isFirstTime && iTemp == 0))
            {
                iTemp++;
                result += subStr(#HEXDIGITS,iTemp,1);
            }
            iValue = iValue << 4;
        }
        while ((digits > 0) && (strLen(result) < digits))
        {
            result  = '0' + result;
        }
        return result;
    }

    static int int642int(int64 _value, boolean _throwIfError = true)
    {
        // cast int64 to integer with optional check for overflow
        if (_value >= 0)
        {
            if (_throwIfError && _value > intMax())
            {
                throw(error(Error::wrongUseOfFunction(funcName())));
            }
            return any2int(_value);
        }

        if (_throwIfError && _value < intMin())
        {
            throw(error(Error::wrongUseOfFunction(funcName())));
        }
        return any2int(_value);
    }

    static int64 int64Max()
    {
        return 0x7fffffffffffffff;
    }

    static int64 int64Min()
    {
        return 0x8000000000000000u;
    }

    static int intMax()
    {
        return maxInt();
    }

    static int intMin()
    {
        return minInt();
    }

    /// <summary>
    /// Calculates the sale price based on the purchase price and the contribution ratio.
    /// </summary>
    /// <param name="purchase">The purchase price.</param>
    /// <param name="contribution_ratio">The contribution ratio.</param>
    /// <returns>The sale price based on the purchase price and the contribution ratio.</returns>
    static real inverseContributionRatio(real purchase, real contribution_ratio)
    {
        return idg(purchase, contribution_ratio);
    }

    static boolean isAOS()
    {
        return xGlobal::isAOS();
    }

    static boolean isClientThin()
    {
        return Session::aosClientMode() == AOSClientMode::Thin;
    }

    //To be used instead of appl.isConfigMode() to avoid c/s calls.
    static boolean isConfigMode()
    {
        SysGlobalCache  cache   = classfactory.globalCache();
        boolean         value;

        if (cache.isSet(classStr(Global), funcName()))
            return cache.get(classStr(Global), funcName());

        value = appl.isConfigMode();
        cache.set(classStr(Global), funcName(), value);
        return value;
    }

    static boolean isConfigurationkeyEnabled(ConfigurationKeyId configurationkey)
    {
        return DictConfigurationKey::enabledById(configurationkey);
    }

    static boolean isCustomControl(FormControl control)
    {
        SysDictClass controlClass;
        SysAttribute formControlAttribute;
        
        controlClass = new SysDictClass(classIdGet(control));
        formControlAttribute = controlClass.getAttribute("FormControlAttribute");
        return (formControlAttribute != null);
    }

    /// <summary>
    /// Gets whether the current user has development rights.
    /// </summary>
    /// <returns>A boolean value.</returns>
    public static boolean isDeveloper()
    {
        SecurityRights rights = SecurityRights::construct();

        return rights.isDeveloper();
    }

    /// <summary>
    /// Gets whether the developer toolkit is installed.
    /// </summary>
    /// <returns>True if the development kit is installed in the server; otherwise, false.</returns>
    public static boolean isDeveloperToolkitInstalled()
    {
        System.Collections.Specialized.NameValueCollection collection = System.Configuration.ConfigurationManager::Get_AppSettings();
        str toolsCount = collection.Get("Infrastructure.VSToolsCount");        
        // Infrastructure.VSToolsCount is available only on Azure deployments. Intertal onebox deployment does not have it in web.config.
        // The value is either 0 or > 0. A zero value indicates that the dev tools is NOT installed
        return !toolsCount || str2Int(toolsCount) > 0;
    }

    /// <summary>
    /// Gets whether the debug flags of the system are installed.
    /// </summary>
    /// <returns>True if the development kit is installed in the server and the user is an admin and a developer.</returns>
    public static boolean debugFlags()
    {
        if (debugFlags == UnknownNoYes::Unknown)
        {
            boolean debugFlagsCalc = isDeveloper() && isDeveloperToolkitInstalled();
            debugFlags = debugFlagsCalc? UnknownNoYes::Yes : UnknownNoYes::No;
        }
        return debugFlags == UnknownNoYes::Yes;
    }

    /// <summary>
    /// Gets the Origin from the url
    /// </summary>
    /// <returns>Origin from url.For example for url like https://test.dynamics.com/namespace/{guid}/default.htm it will return https://test.dynamics.com</returns>
    internal static str GetOriginFromUrl()
    {
        System.Uri currentUrl;
        str result = null;
        System.String partialStringUri;

        currentUrl = Global::GetCurrentUri();
        if (currentUrl)
        {
            result = currentUrl.GetLeftPart(System.UriPartial::Authority);
        }
        
        return result;
    }

    /// <summary>
    /// Gets the Deployment location from a URL
    /// </summary>
    /// <returns>A Deployment locationL. Return is based on extracting the url before the ending slash which is the deployment location.For example for url like https://test.dynamics.com/namespace/{guid}/default.htm it will return https://test.dynamics.com/namespace/{guid}</returns>
    internal static str GetDeploymentLocation()
    {
        System.Uri currentUrl;
        str result = null;
        System.String partialStringUri;

        currentUrl = Global::GetCurrentUri();
        if (currentUrl)
        {
            partialStringUri = currentUrl.GetLeftPart(System.UriPartial::Path);
            result = partialStringUri.Substring(0, partialStringUri.LastIndexOf('/'));
        }
        
        return result;
    }

    /// <summary>
    /// Gets the current request uri
    /// </summary>
    /// <returns>the current request uri</returns>
    internal static System.Uri GetCurrentUri()
    {
        Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext sessionContext;
        System.Uri currentUrl = null;

        sessionContext = Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext::get_Current();
        if (sessionContext)
        {
            currentUrl = sessionContext.get_RequestUrl();
        }

        return currentUrl;
    }

    /// <summary>
    /// Gets the value of the query paramter from the client URL.
    /// </summary>
    /// <param name = "_queryParameter">The query parameter of the request on the client.</param>
    /// <returns>The value in the URL if the query parameter exists.</returns>
    public static str getClientURLQueryValue(str _queryParameter)
    {
        if (!hasGUI())
        {
            return '';
        }

        str value = '';
        System.Uri uri = Global::GetCurrentUri();
        if (uri)
        {
            System.String url = Microsoft.Dynamics.AX.Framework.Utilities.UrlHelper.UrlUtility::GetUrl(uri);
            if (url)
            {
                System.Uri decodedUri = new System.Uri(url);
                System.String[] modeKeyValue = System.Web.HttpUtility::ParseQueryString(decodedUri.Query).GetValues(_queryParameter);
                    
                if (modeKeyValue != null && modeKeyValue.Length >= 1)
                {
                    value = modeKeyValue.Get(0);
                }
            }
        }
        return value;
    }

    /// <summary>
    /// Gets whether the product is a preview build or not.
    /// </summary>
    /// <returns>true if preview build is enabled.</returns>   
    public static boolean isProductPreviewBuild()
    {
        if (isPreviewBuildCalculated == false) 
        {
            isPreviewBuild = true; // default to not preview biuld
     
            // retrieve the version information off the real file
            str assemblyName = xInfo::directory(DirectoryType::Bin) + 'ApplicationPlatform\\bin\\Microsoft.Dynamics.Client.ServerForm.dll';

            if (System.IO.File::Exists(assemblyName))
            {
                System.Diagnostics.FileVersionInfo fileVersioninfo = System.Diagnostics.FileVersionInfo::GetVersionInfo(assemblyName);
                System.String productVersion = fileVersionInfo.ProductVersion; 
                // now parse apart the product version for ring information
                if (strContains(productVersion, "Ring")) {
                    System.String[] splitters = new System.String[1]();
                    splitters.SetValue("Ring_", 0);
                    System.String[] temp = productVersion.Split(splitters, System.StringSplitOptions::None);
                    // is it greater than ring_2
                    if (str2Int(temp.get_Item(1)) > 2) {
                        isPreviewBuild = false;
                    }
                }
            }
            isPreviewBuildCalculated = true;
        }

        return isPreviewBuild;
    }

    /// <summary>
    /// Gets whether the product is a embedded app (client url driven)
    /// </summary>
    /// <returns>true if preview build is enabled.</returns>
    public static boolean isAppEmbedded()
    {
        str queryValue;

        if (isAppEmbeddedCalculated == false)
        {
            isAppEmbedded = false; // default to not Embedded
            queryValue = getClientURLQueryValue("embedded");

            if (queryValue == "true")
            {
                isAppEmbedded = true;
            }
            isAppEmbeddedCalculated = true;
        }

        return isAppEmbedded;
    }

    /// <summary>
    /// Retrieves the build version values of a given module
    /// </summary>
    /// <returns>
    /// container with module, major, minor, build and version
    /// </returns>
    private static container GetModuleBuildInfo(str moduleToFind)
    {
        container moduleData;

        Microsoft.Dynamics.AX.Metadata.MetaModel.ModelInfo modelInfo;
        CLRObject modules;
        ClrObject modulesEnumerator;
        CLRObject moduleModels;
        CLRObject modelEnumerator;
        str60 moduleName;

        // look for application version information
        modules = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetInstalledModuleNamesInSortedOrder();
        modulesEnumerator = modules.GetEnumerator();

        while (modulesEnumerator.MoveNext())
        {
            moduleName = modulesEnumerator.get_Current();
            
            moduleModels = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetModelsInModuleSortedByDisplayName(moduleName);
            modelEnumerator = moduleModels.GetEnumerator();
            while (modelEnumerator.MoveNext())
            {
                modelInfo = modelEnumerator.get_Current();

                if (modelInfo.Name == moduleToFind)
                {
                    moduleData = conIns(moduleData, VersionMajor, modelInfo.VersionMajor);
                    moduleData = conIns(moduleData, VersionMinor, modelInfo.VersionMajor);
                    moduleData = conIns(moduleData, VersionBuild, modelInfo.VersionBuild);
                    moduleData = conIns(moduleData, VersionRevision, modelInfo.VersionRevision);
                    break;
                }
            }
        }
        return moduleData;
    }

    /// <summary>
    /// Gets whether the specified client side debug flag is defined.
    /// </summary>
    /// <param name = "_debugFlag">The client flag to check.</param>
    /// <returns>true if the debug flag is enabled.</returns>
    public static boolean clientDebugFlagCheck(str _debugFlag)
    {
        if (!hasGUI())
        {
            return false;
        }

        if (!clientDebugFlags.exists(_debugFlag))
        {
            NoYes valueSet = NoYes::No;
            str debugValue = getClientURLQueryValue('debug');
            if (strLwr(debugValue) == strLwr(_debugFlag))
            {
                valueSet = NoYes::Yes;
            }
            clientDebugFlags.insert(_debugFlag, valueSet);
        }
        return clientDebugFlags.lookup(_debugFlag) == NoYes::Yes;
    }

    static boolean isGuest()
    {
        return xGlobal::isGuest();
    }

    static boolean isInteger(str txt)
    {
        return str2IntOk( txt );
    }

    static boolean isLanguageArabic(str lang)
    {
        #define.LOWERCASE_AR('ar')

        str language;

        language = strLwr(subStr(lang, 0, 2));
        return (language == #LOWERCASE_AR);
    }

    /// <summary>
    ///    Checks if the specified language is 'Right to Left'.
    /// </summary>
    /// <param name="_languageId">
    ///    The language to check.
    /// </param>
    /// <returns>
    ///    true if the language is RTL; otherwise, false.
    /// </returns>
    static boolean isLanguageRTL(LanguageId _languageId)
    {
        #Languages
        str lcLang;

        lcLang = strLwr(subStr(_languageId, 0, 2));
        return (#arabicPrefix == lcLang ||
                #farsiPrefix == lcLang  ||
        #pashtoPrefix == lcLang ||
        #urduPrefix == lcLang   ||
        #hebrewPrefix == lcLang);
    }

    static boolean isNative()
    {
        return ! appl.isSqlConnected();
    }

    /// <summary>
    /// Indicates whether the record template prompt should be suppressed for the given table.
    /// </summary>
    /// <param name="tabid">
    /// The Table ID of the given table.
    /// </param>
    /// <returns>
    /// true if the prompt should be suppressed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This is the location for application teams to add tables for which a record template prompt should
    /// be suppressed.
    /// </remarks>
    public static boolean isRecordTemplatePromptSuppressed(TableId tabid)
    {
        boolean isSuppressed = false;

        switch(tabid)
        {
            default:
                isSuppressed=false;
                break;
        }

        return isSuppressed;
    }

    static boolean isRunningMode()
    {
        SysGlobalCache cache = classfactory.globalCache();
        boolean        mode;

        if (cache.isSet(classStr(Global), funcName()))
            return cache.get(classStr(Global), funcName());

        if (! appl)
        {
            return false;
        }

        mode = appl.isRunningMode();
        cache.set(classStr(Global), funcName(), mode);
        return mode;
    }

    /// <summary>
    /// Gets whether the current session is running within a batch context.
    /// </summary>
    /// <returns>true if the execution is under a batch job.</returns>
    public static boolean isRunningOnBatch()
    {
        System.Collections.Specialized.NameValueCollection collection = System.Configuration.ConfigurationManager::Get_AppSettings();
        str isRunningOnBatchValue = collection.Get("Application.BatchHost");

        return isRunningOnBatchValue != '';
    }

    /// <summary>
    /// Gets whether the current session is running within a database synchronization (post synchronization X++) context.
    /// </summary>
    /// <returns>
    /// True if the execution's HostingEnvironment is 'HostingEnvSyncEngine'.
    /// </returns>
    public static boolean isRunningSyncEngine()
    {
        System.Collections.Specialized.NameValueCollection collection = System.Configuration.ConfigurationManager::Get_AppSettings();
        str isRunningOnDBSyncValue = collection.Get("Microsoft.Dynamics.AX.AosConfig.Config.HostingEnvironment");

        return isRunningOnDBSyncValue == "HostingEnvSyncEngine";
    }

    [SysObsoleteAttribute("X++ code is always executed on the server", true, 13\02\2014)]
    static boolean isRunningOnServer()
    {
        return true;
    }

    static boolean isSessionActive(Integer      _sessionId,
                                   utcdatetime  sessionLoginDateTime,
                                   boolean      checkSession = false
                                  )
    {
        xSession xSession;
        SysClientSessions session;

        select session where session.SessionId == _sessionId;
        if ( session && session.Status > 0 )
        {
            xSession = new xSession(_sessionId,checkSession);
            if (xSession)
            {

                if (xSession.loginDateTime() != sessionLoginDateTime)
                    return false;

                return true;
            }
        }
        return false;
    }

    static boolean isSysId(int _id)
    {
        return _id >= 0xf000 && _id <= 0xffff;
    }

    public static boolean isSystemAdministrator()
    {
        SecurityRights rights = SecurityRights::construct();

        return rights.isSystemAdministrator();
    }

    static boolean isTableUserEnabled(TableId tableId, AccessType accessType = AccessType::Edit)
    {
        DictTable dt=new DictTable(tableId);

        //validate arguments before using them
        if (dt == null)
            return false;
        else
            return dt.rights() >= accessType;
    }

    static boolean isType(ExtendedTypeId _extendedTypeId, ExtendedTypeId _isExtendedTypeId)
    {
        DictType dictType;

        if (!_extendedTypeId)
        {
            return false;
        }

        if (_extendedTypeId == _isExtendedTypeId)
        {
            return true;
        }

        dictType = new DictType(_extendedTypeId);

        if (dictType != null)
        {
            return isType(dictType.extend(), _isExtendedTypeId);
        }
        else
        {
            return false;
        }
    }

    /*
        Tests whether the specified type is inherited from a timeOfDay type
        */
    static boolean isTypeTime(ExtendedDataTypeName _typeName)
    {
        return isType(extendedTypeName2Id(_typeName), extendedTypeNum(TimeOfDay));
    }

    //Returns whether or not the passed in text is a valid AOT name
    public static boolean isValidAOTName(str sText)
    {
        int i, len = strLen(sText);
        char c;

        for (i=1; i<=len; ++i)
        {
            c = subStr(sText,i,1);

            if( !('0' <= c && c <= '9') &&
                !('a' <= c && c <= 'z') &&
                !('A' <= c && c <= 'Z') &&
                !('_' == c) )
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Check whether the string is a URL. Both relative and absolute URLs
    /// are acceptable. The syntax allows http:// and https:// prefix, but 
    /// no other protocols.
    /// <note>If you need a stronger and more correct validation, please use  
    /// the static Uri.IsWellFormedUriString(String, UriKind) method</note>
    /// </summary>
    /// <param name = "url">The url to test</param>
    /// <returns>True if the url is a relative or absolute URL, false otherwise.</returns>
    static boolean isValidURL(URL url)
    {
        InteropPermission   permission;
        boolean             ret;
        str                 urlFilter;
        System.Text.RegularExpressions.Regex regEx;
        System.Text.RegularExpressions.Match regMatch;

        permission = new InteropPermission(InteropKind::ClrInterop);
        permission.assert();

        // Debug tip: Regular expressions can easily be checked in console
        // applications or in regex testers based in web sites: One is here:
        // https://www.regextester.com/93652
        // Regular expressions are described here: https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference

        urlFilter = @"^"  // Start. Nothing allowed before valid string
        + @"(http(s?)\:\/\/)?"   // Optional http(s)://
        + @"[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*" // Any number of words separated by dots or -
        + @"(:(0-9)*)*"                       // Optional sequence of colon and digit, for port number.
        + @"(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&;%\$=#_]*)?" // Junk following, sequence of letters, digits, -, ?, ,, '
        + @"$"; // End. Whole string has to be matched

        //BP Deviation documented
        regEx = new System.Text.RegularExpressions.Regex(urlFilter);
        regMatch = regEx.Match(url);
        ret = regMatch.get_Success();

        return ret;
    }

    /// <summary>
    /// Checks whether the curext() is part of a virtual company or not.
    /// </summary>
    /// <returns>
    /// true if the curext() is part of a virtual company; otherwise, false.
    /// </returns>
    public static boolean isVirtualCompany()
    {
        VirtualDataAreaList     vc1;
        container               result;
        SysGlobalObjectCache    globalCache;

        //Try put pull from cache first
        globalCache = classfactory.globalObjectCache();
        result = globalCache.find(#ISVIRTUALCOMPANY, [curext()]);

        if(result != conNull())
        {
            return conPeek(result, 1);
        }

        select firstonly RecId from vc1 where vc1.Id == curext();

        globalCache.insert(#ISVIRTUALCOMPANY, [curext()], [vc1.RecId != 0]);

        return (vc1.RecId != 0);
    }

    /// <summary>
    /// convert Japanese Era date to Gregorian date
    /// </summary>
    /// <param name="_date">
    /// The Japanese Era date value
    /// </param>
    /// <returns>
    /// return Gregorian date converted from Japanese Era date if the length of parameter "_date" permitted, else return null date.
    /// </returns>
    // <GJP>
    public static date japaneseEraStr2Date_JP(str _date)
    {
        date    gregdate;
        int     era;
        int     mth;
        int     day;
        int     strLength;
        str     tempStr;
        #define.Numbers("0123456789")
        #define.PositionOne(1)
        #define.PositionTwo(2)
        #define.PositionThree(3)
        #define.PositionFive(5)
        #define.BaseEraYear(1988)
        #define.LengthAllowed(6)

        tempStr   = _date;
        strLength = strLen(tempStr);

        if (strLength > #LengthAllowed)
        {
            tempStr = strRem(_date, #Numbers);
            tempStr = strRem(_date, tempStr);
        }

        if (strLength == #LengthAllowed
            || (strLength > #LengthAllowed && strLen(tempStr) == #LengthAllowed))
        {
            era      = str2int(subStr(tempstr, #PositionOne, #PositionTwo));
            mth      = str2int(subStr(tempstr, #PositionThree, #PositionTwo));
            day      = str2int(subStr(tempstr, #PositionFive, #PositionTwo));
        }

        if (era != 0
            && mth != 0
            && day != 0)
        {
            gregdate = mkDate(day, mth, era + #BaseEraYear);
        }
        else
        {
            checkFailed("@GLS63107");
            // The Japanese date should be in YY/MM/DD format.
        }

        return gregdate;
    }

    // </GJP>

    public static FormLinkType joinMode2LinkType(JoinMode _joinMode)
    {
        switch (_joinMode)
        {
            case JoinMode::ExistsJoin :
                return FormLinkType::ExistJoin;
            case JoinMode::InnerJoin :
                return FormLinkType::InnerJoin;
            case JoinMode::NoExistsJoin :
                return FormLinkType::NotExistJoin;
            case JoinMode::OuterJoin :
                return FormLinkType::OuterJoin;
            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

    static container languageList()
    {
        return xGlobal::languageList();
    }

    static boolean layerExists(UtilEntryLevel layer)
    {
        UtilFile newUtil = new UtilFile('aod');
        str layers = newUtil.layers();
        int j;

        while (strLine(layers, j))
        {
            if (strLine(layers, j) == enum2str(layer))
                return true;
            j++;
        }

        return false;
    }

    /// <summary>
    ///    Converts the legacy ID of an element to the name of an element.
    /// </summary>
    /// <param name="_type">
    ///    The type of the element.
    /// </param>
    /// <param name="_legacyId">
    ///    The legacy ID of the element.
    /// </param>
    /// <param name="_parentName">
    ///    The name of the parent of the element; optional.
    /// </param>
    /// <returns>
    ///    The name of the element that has the specified legacy ID; otherwise, an empty string.
    /// </returns>
    public static UtilElementName legacyID2Name(
        UtilElementType _type,
        int             _legacyId,
        UtilElementName _parentName = ''
    )
    {
        UtilElementId parentId;
        UtilIdElements utilElements;

        switch (_type)
        {
            case UtilElementType::TableField:
            case UtilElementType::TableIndex:
                parentId = tableName2id(_parentName);
                break;

            default:
                parentId = 0;
                break;
        }

        select firstonly Name from utilElements
            where utilElements.Id == _legacyId &&
                  utilElements.ParentId == parentId &&
                  utilElements.RecordType == _type;

        if (utilElements)
            return utilElements.Name;

        return '';
    }

    static int loadArrayFromXML (XmlNode n, Array a)
    {
        XmlNamedNodeMap attrs;
        XmlNode elementNode = n;
        Struct s;
        int indexValue;

        //validate arguments before using them
        if (n == null)
            return  0;
        elementNode = n.firstChild();
        while (elementNode)
        {
            attrs = elementNode.attributes();
            indexValue = str2int(attrs.getNamedItem('index').text());

            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            // s = valueFromXMLNode(a.typeId(), elementNode);
            if (elementNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                s = valueFromXMLNode(a.typeId(), elementNode.firstChild());
            else
                // Simple value
                s = valueFromXMLNode(a.typeId(), elementNode);
            // Syp Modifications - SP3 - ENd


            a.value(indexValue, s.value('value'));
            elementNode = elementNode.nextSibling();
        }
        return 0;
    }

    static int loadListFromXML(XmlNode n, List l)
    {
        XmlNode elementNode;
        Struct s;

        //validate arguments before using them
        if (n == null)
            return  0;
        elementNode = n.firstChild();
        while (elementNode)
        {
            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            // s = valueFromXMLNode(l.typeId(), elementNode);
            if (elementNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                s = valueFromXMLNode(l.typeId(), elementNode.firstChild());
            else
                // Simple valu
                s = valueFromXMLNode(l.typeId(), elementNode);
            // Syp Modifications - SP3 - ENd

            l.addEnd(s.value('value'));
            elementNode = elementNode.nextSibling();
        }
        return 0;
    }

    static int loadMapFromXML(XmlNode n, Map m)
    {
        XmlNode elementNode;
        XmlNode keyNode, valueNode;
        Struct keyValue, valueValue;

        //validate arguments before using them
        if (n == null)
            return  0;
        elementNode = n.firstChild();

        while (elementNode)
        {
            // Get the key and value nodes.
            keyNode = elementNode.firstChild();
            valueNode = keyNode.nextSibling();

            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            // keyValue = valueFromXMLNode(m.keyType(), keyNode);
            // valueValue = valueFromXMLNode(m.valueType(), valueNode);
            if (keyNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                keyValue = valueFromXMLNode(m.keyType(), keyNode.firstChild());
            else
                // Simple value
                keyValue = valueFromXMLNode(m.keyType(), keyNode);

            if (valueNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                valueValue = valueFromXMLNode(m.valueType(), valueNode.firstChild());
            else
                // Simple value
                valueValue = valueFromXMLNode(m.valueType(), valueNode);
            // Syp Modifications - SP3 - ENd

            m.insert(keyValue.value('value'), valueValue.value('value'));

            elementNode = elementNode.nextSibling();
        }
        return 0;
    }

    static int loadSetFromXML(XmlNode n, Set s)
    {
        XmlNode elementNode;
        Struct res;

        //validate arguments before using them
        if (n == null)
            return  0;
        elementNode = n.firstChild();

        while (elementNode)
        {
            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            // res = valueFromXMLNode(s.typeId(), elementNode);
            if (elementNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                res = valueFromXMLNode(s.typeId(), elementNode.firstChild());
            else
                // Simple value
                res = valueFromXMLNode(s.typeId(), elementNode);
            // Syp Modifications - SP3 - ENd

            s.add(res.value('value'));
            elementNode = elementNode.nextSibling();
        }
        return 0;
    }

    static int loadStructFromXML(XmlNode n, Struct s)
    {
        XmlNode elementNode;
        XmlNamedNodeMap attrs;
        Types fieldType;
        str fieldName;
        Struct res;

        //validate arguments before using them
        if (n == null)
            return  0;
        elementNode = n.firstChild();

        while (elementNode)
        {
            // Get the name and type...
            attrs = elementNode.attributes();
            fieldType = xmlGetTypeFromSpelling(attrs.getNamedItem('type').text());
            fieldName = attrs.getNamedItem('name').text();

            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            // res = valueFromXMLNode(fieldType, elementNode);
            if (elementNode.hasChildNodes())
                // Composite value. Dig into the the <value> ... </values>
                res = valueFromXMLNode(fieldType, elementNode.firstChild());
            else
                // Simple value
                res = valueFromXMLNode(fieldType, elementNode);
            // Syp Modifications - SP3 - ENd

            s.value(fieldName, res.value('value'));

            elementNode = elementNode.nextSibling();
        }
        return 0;
    }

    /// <summary>
    /// Converts list to container, saving the order of content.
    /// </summary>
    /// <param name = "_list">List to convert.</param>
    /// <returns>Container with list objects in same order.</returns>
    public static container list2Con(List _list)
    {
        container cont = conNull();
        if (_list)
        {
            ListEnumerator iter = _list.getEnumerator();

            while (iter.moveNext())
            {
                cont += [iter.current()];
            }
        }
        return cont;
    }

    public static container map2Con(Map _map)
    {
        MapEnumerator mapEnum = _map.getEnumerator();
        container conKeys = conNull(), conValues = conNull();

        while (mapEnum.moveNext())
        {
            conKeys += mapEnum.currentKey();
            conValues += mapEnum.currentValue();
        }

        return [conKeys, conValues];
    }

    /// <summary>
    /// Validates if table is mapped.
    /// </summary>
    /// <param name="_mapId">
    /// Map Id.
    /// </param>
    /// <param name="_tableId">
    /// Table Id.
    /// </param>
    /// <param name="_mapField">
    /// Map field Id.
    /// </param>
    /// <param name="_tableField">
    /// Table field Id.
    /// </param>
    /// <returns>
    /// true if table is mapped to the specified map.
    /// </returns>
    /// <remarks>
    /// Depending on additional parameters validation drills down to fields mapping.
    /// <list type="bullet">
    /// <item>If <paramref name="_mapField"/> and <paramref name="_tableField"/> are empty:
    /// returns true if the <paramref name="_mapId"/> map have a mapping for table <paramref name="_tableId"/></item>
    /// <item>If <paramref name="_mapField"/> is not empty:
    /// returns true if the <paramref name="_mapId"/> map have a mapping for it's field <paramref name="_mapField"/> for table <paramref name="_tableId"/></item>
    /// <item>If <paramref name="_tableField"/> is not empty:
    /// returns true if the <paramref name="_mapId"/> map have a mapping for table's field <paramref name="_tableField"/> for table <paramref name="_tableId"/></item>
    /// <item>If <paramref name="_mapField"/> and <paramref name="_tableField"/> are not empty:
    /// returns true if <paramref name="_mapField"/> is a mapping for <paramref name="_tableField"/> on map <paramref name="_mapId"/> for table <paramref name="_tableId"/></item>
    /// </list>
    /// </remarks>
    static public boolean mappingExists(
        TableId _mapId,
        TableId _tableId,
        FieldId _mapField   = 0,
        FieldId _tableField = 0)
    {
        boolean          ok;
        Map              map = MappingsInfo_RU::createMapWithFieldId( _tableId, _mapId);
        IdentifierName   fieldName;

        if (!map.empty())
        {
            if (_mapField || _tableField)
            {
                if (_mapField && _tableField)
                {
                    fieldName = fieldId2name(_mapId, _mapField);

                    if (map.exists(fieldName) && (map.lookup(fieldName) == _tableField))
                    {
                        ok = true;
                    }
                }
                else if (_mapField)
                {
                    if (map.keySet().in(fieldId2name(_mapId, _mapField)))
                    {
                        ok = true;
                    }
                }
                else if (_tableField)
                {
                    if (map.valueSet().in(_tableField))
                    {
                        ok = true;
                    }
                }
            }
            else
            {
                ok = true;
            }
        }

        return ok;
    }

    static RecId maxRecId()
    {
        return 0x7fffffffffffffffu;
    }

    static real maxUInt()
    {
        return 4294967295.0;
    }

    /// <summary>
    ///    Retrieves a large percentage value.
    /// </summary>
    /// <returns>
    ///    A value of 99999999999999.99.
    /// </returns>
    /// <remarks>
    ///    The Percent extended data type can hold a larger value, but for user interface purposes this value
    ///    is desirable.
    /// </remarks>
    static real maxUIPercent()
    {
        return 99999999999999.99;
    }

    static MenuItemType menuItemTypeStr2Type(str _menuItemTypeStr)
    {
        switch (_menuItemTypeStr)
        {
            case 'D' : return MenuItemType::Display;
            case 'O' : return MenuItemType::Output;
            case 'A' : return MenuItemType::Action;
            default  : return MenuItemType::Display;
        }
    }

    static RealBase minOne(RealBase value)
    {
        if (!value)
            return 1;

        return value;
    }

    static RecId minRecId()
    {
        return 0;
    }

    static int modulo10(str numeralsTxt, boolean calculateControl = false)
    {
        int     idx;
        int     control;
        int     sumvalue;
        int     lengthTxt;

        if (calculateControl)
            numeralsTxt = numeralsTxt + '0';

        lengthTxt   = strLen(numeralsTxt);
        idx         = lengthTxt;

        while (idx >= 1)
        {
            sumvalue = str2int(subStr(numeralsTxt, idx, 1)) * (((lengthTxt - idx) mod 2) + 1);
            control += (sumvalue mod 10) + (sumvalue div 10);
            idx--;
        }

        control = (10 - (control mod 10)) mod 10;

        return control;
    }

    static int modulo11(str 20 numeralsTxt)
    {
        int             numerals;
        int             vector;
        int             sumNumerals;

        vector      = 2;
        sumNumerals = 0;
        numeralsTxt = strKeep(numeralsTxt,'0123456789');

        sumNumerals = str2int(subStr(numeralsTxt,999,-2));
        numeralsTxt =         strDel(numeralsTxt,999,-2);

        while (numeralsTxt)
        {
            numerals    = str2int(subStr(numeralsTxt,999,-2)) * vector;
            numeralsTxt =         strDel(numeralsTxt,999,-2);

            sumNumerals += numerals;
            vector     += 1;

            if (vector > 7)
            {
                vector = 2;
            }
        }

        return ((sumNumerals mod 11) == 0);
    }

    /* Month name in local declension (LV - language specific) */
    #define.LV("LV")
    static MonthName monthNumberToName_LV(Months _num, LanguageId _languageId = #LV)
    {
        #define.january(1)
        #define.february(2)
        #define.march(3)
        #define.april(4)
        #define.may(5)
        #define.june(6)
        #define.july(7)
        #define.august(8)
        #define.september(9)
        #define.october(10)
        #define.november(11)
        #define.december(12)

        MonthName   ret;
        Label       label = _languageId ? new Label(_languageId) : new Label();

        switch (_num)
        {
            case #january :
                ret = label.extractString(literalStr("@GLS108549"));
                break;

            case #february :
                ret = label.extractString(literalStr("@GLS108550"));
                break;

            case #march :
                ret = label.extractString(literalStr("@GLS108551"));
                break;

            case #april :
                ret = label.extractString(literalStr("@GLS108553"));
                break;

            case #may :
                ret = label.extractString(literalStr("@GLS108554"));
                break;

            case #june :
                ret = label.extractString(literalStr("@GLS108552"));
                break;

            case #july :
                ret = label.extractString(literalStr("@GLS108555"));
                break;

            case #august :
                ret = label.extractString(literalStr("@GLS108556"));
                break;

            case #september :
                ret = label.extractString(literalStr("@GLS108557"));
                break;

            case #october :
                ret = label.extractString(literalStr("@GLS108558"));
                break;

            case #november :
                ret = label.extractString(literalStr("@GLS108559"));
                break;

            case #december :
                ret = label.extractString(literalStr("@GLS108560"));
                break;

            default :
                throw error(strFmt("@SYS54195",funcName()));
        }

        return ret;
    }

    static date naDate()
    {
        return dateMax();
    }

    static int naInt()
    {
        return intMin();
    }

    static str name2Alias(str _name)
    {
        return strRem(_name,  ' .,;/-:\\+'  );
    }

    static real naReal()
    {
        return realMin();
    }

    static TempStr naStr()
    {
        return num2char(255);
    }

    static anytype nullValue(anytype a)
    {
        return nullValueBaseType(typeOf(a));
    }

    /// <summary>
    /// Returns default (null) value for a given base type.
    /// </summary>
    /// <param name="_baseType">
    /// Base type
    /// </param>
    /// <param name="_enumAsInt">
    /// Treat base enum as integer
    /// </param>
    /// <returns>
    /// Default value for a given base type.
    /// </returns>
    /// <remarks>
    /// <paramref name="_enumAsInt"/>: In some cases the kernel expects an integer instead of enum value.
    /// For example when "adding" a struct it must be a enum, when setting a enum it must a integer.
    /// </remarks>
    static anytype nullValueBaseType(
        Types   _baseType,
        boolean _enumAsInt = false)
    {
        Common common;

        switch (_baseType)
        {
            case Types::Container:
                return conNull();

            case Types::Date:
                return dateNull();

            case Types::UtcDateTime:
                return utcDateTimeNull();

            case Types::Enum:
                    if (_enumAsInt)
                    return 0;
                return false; //Do not return noYes::No, as it is incompatible with all other enums;

            case Types::Integer:
                return 0;

            case Types::Real:
                return 0.0;

            case Types::Record:
                return common;

            case Types::String,
                    Types::RString,
                 Types::VarString:
                return '';

            case Types::Class:
                return null;

            case Types::UserType:
                return 0;

            case Types::Int64:
                return any2int64(0);

            case Types::Guid:
                return str2guid('{00000000-0000-0000-0000-000000000000}');
        }
        return 0;
    }

    static anytype nullValueFromType(Types basetype)
    {
        switch (basetype)
        {
            case Types::String:
            case Types::VarString:
            case Types::RString:
                return '';
            case Types::Integer:
            case Types::Int64:
            case Types::Real:
            case Types::Time:
            case Types::Enum:       //Do not assume any type, like noYes::No
                return 0;
            case Types::Date:
                return dateNull();
            case Types::UtcDateTime:
                return utcDateTimeNull();
            case Types::Guid:
                return str2guid('{00000000-0000-0000-0000-000000000000}');
            case Types::Container:
                return conNull();
            default:
                throw error(strFmt("@SYS12580",basetype));
        }
    }

    static str num2expstr(real r, int _separator1 = 1, int _separator2 = 0)
    {
        real log  = (r?log10(abs(r)):0);
        int  decs = real2int(log);
        real factor;

        int i;

        if (decs<=0 && frac(log))
            decs--;

        if (decs > 7 || decs < -1)  //use exponent notation
        {
            factor = decs<0?10:0.1;
            for (i=1;i<=abs(decs);i++)
                r = r * factor;
            //        r = r / exp10(decs);  //gives rounding error
            return num2str(r,0,numOfDec(r),1,0)+(decs?'e'+int2str(decs):'');
        }
        return num2str(r,0,numOfDec(r), _separator1, _separator2);
    }

    static TempStr num2Str0(real      value,
                            int       length,
                            int       numOfDec = 0,
                            int       sepDec   = 0,
                            int       sep1000  = 0
                           )
    {
        str 100         curTxt;
        boolean negative = false;

        if (value < 0.0)
        {
            value = -value;
            negative = true;
            length -= 1;
        }

        curTxt = num2str(value, 0, numOfDec, sepDec, sep1000);
        curTxt = strRep('0', length - strLen(curTxt)) + curTxt;

        if (negative)
        {
            curTxt = '-' + curTxt;
        }

        return curTxt;
    }

    static TempStr num2Text(real numerals)
    {

        #DEFINE.NumDec(2)

        str    1        digit;
        str   30        numeralsTxt;
        str  250        characters;

        numeralsTxt= num2str(numerals,0,#NumDec,2,0);
        characters= "";

        while (numeralsTxt)
        {
            digit  = subStr(numeralsTxt,1,1);
            numeralsTxt= strDel(numeralsTxt,1,1);

            switch(digit)
            {
                case '0': characters+= "@SYS2068";
                    break;
                case '1': characters+= "@SYS5437";
                    break;
                case '2': characters+= "@SYS26621";
                    break;
                case '3': characters+= "@SYS8860";
                    break;
                case '4': characters+= "@SYS5232";
                    break;
                case '5': characters+= "@SYS4069";
                    break;
                case '6': characters+= "@SYS8502";
                    break;
                case '7': characters+= "@SYS15319";
                    break;
                case '8': characters+= "@SYS12322";
                    break;
                case '9': characters+= "@SYS5479";
                    break;

                default:   characters+= numeralsTxt+'/1'+strRep('0',#NumDec);
                    numeralsTxt = '';

                    break;
            }
            characters+= ' ';
        }
        return characters;
    }

    /// <summary>
    /// This method is used to convert a number to Thai text.
    /// </summary>
    /// <param name="_num">
    /// The number to convert.
    /// </param>
    /// <returns>
    /// The converted result of money amount in Thai text.
    /// </returns>
    /// <remarks>
    /// The number is rounded to two decimal places. And the sign of number is ignored.
    /// </remarks>
    // <GTH>
    static TempStr numeralsToThaiTxt(real _num)
    {
        #define.DigitZero('ศูนย์')
        #define.DigitOne('หนึ่ง')
        #define.DigitTwo('สอง')
        #define.DigitThree('สาม')
        #define.DigitFour('สี่')
        #define.DigitFive('ห้า')
        #define.DigitSix('หก')
        #define.DigitSeven('เจ็ด')
        #define.DigitEight('แปด')
        #define.DigitNine('เก้า')

        #define.NumEleventh('เอ็ด')
        #define.NumTwenty('ยี่')

        #define.UnitTen('สิบ')
        #define.UnitHundred('ร้อย')
        #define.UnitThousand('พัน')
        #define.UnitTenThousand('หมื่น')
        #define.UnitHundredThousand('แสน')
        #define.UnitMillion('ล้าน')

        #define.WordBaht('บาท')
        #define.WordOnly('ถ้วน')
        #define.WordDecimal('สตางค์')

        #define.BlockDigitsNumber(6)


        str 200     returnTxt;
        str         digit[9];
        str         unit[7];

        int         curDigit;
        int         curBlockLevel;

        int64       integerPart = any2int64(trunc(abs(_num)));
        int         decimalPart = any2int(decRound(frac(abs(_num)), 2) * 100) mod 100;
        int         tenths      = decimalPart div 10 mod 10;
        int         hundredths  = decimalPart mod 10;

        digit[1]    = #DigitOne;
        digit[2]    = #DigitTwo;
        digit[3]    = #DigitThree;
        digit[4]    = #DigitFour;
        digit[5]    = #DigitFive;
        digit[6]    = #DigitSix;
        digit[7]    = #DigitSeven;
        digit[8]    = #DigitEight;
        digit[9]    = #DigitNine;

        unit[1] = '';
        unit[2] = #UnitTen;
        unit[3] = #UnitHundred;
        unit[4] = #UnitThousand;
        unit[5] = #UnitTenThousand;
        unit[6] = #UnitHundredThousand;
        unit[7] = #UnitMillion;


        // Init the base txt
        if (integerPart == 0 && decimalPart == 0)
        {
            returnTxt = #DigitZero + #WordBaht;
        }
        else if (integerPart == 0)
        {
            returnTxt = '';
        }
        else
        {
            returnTxt = #WordBaht;
        }

        // Process the integer part
        curBlockLevel = 1;
        while (integerPart > 0)
        {
            curDigit    = int642int(integerPart mod 10);
            integerPart = integerPart div 10;

            // Add unit for current level
            if (curDigit != 0)
            {
                returnTxt = unit[curBlockLevel] + returnTxt;
            }

            // Add number txt for current level
            if (curBlockLevel == 1)
            {
                if (curDigit == 1 && (integerPart mod 10))
                {
                    returnTxt = #NumEleventh + returnTxt;
                }
                else if (curDigit > 0)
                {
                    returnTxt = digit[curDigit] + returnTxt;
                }
            }
            else if (curBlockLevel == 2)
            {
                if (curDigit == 2)
                {
                    returnTxt = #NumTwenty + returnTxt;
                }
                else if (curDigit > 2)
                {
                    returnTxt = digit[curDigit] + returnTxt;
                }
            }
            else
            {
                if (curDigit > 0)
                {
                    returnTxt = digit[curDigit] + returnTxt;
                }
            }

            curBlockLevel++;
            if (curBlockLevel > #BlockDigitsNumber)
            {
                if (integerPart > 0)
                {
                    returnTxt = unit[curBlockLevel] + returnTxt;
                }

                curBlockLevel = 1;
            }
        }

        // Process decimal part
        if (decimalPart == 0)
        {
            returnTxt += #WordOnly;
        }
        else
        {
            if (tenths == 2)
            {
                returnTxt += #NumTwenty;
            }
            else if (tenths > 2)
            {
                returnTxt += digit[tenths];
            }

            if (tenths > 0)
            {
                returnTxt += #UnitTen;
            }

            if (tenths > 0 && hundredths == 1)
            {
                returnTxt += #NumEleventh;
            }
            else if (hundredths > 0)
            {
                returnTxt += digit[hundredths];
            }

            returnTxt += #WordDecimal;
        }

        return strFmt('(%1)', returnTxt);
    }

    // </GTH>

    static TempStr numeralsToTxt(real _num)
    {
        int     numOfPennies = any2int(decRound(frac(_num), 2) * 100) mod 100;
        real    test         = _num - frac(_num);

        int64   numOfTenths;
        str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;

        int64   temp;
        str 200 returntxt;
        int64   testLoc;

        real modOperator(real a1, real a2)
        {
            int tmpi;
            real tmp1, tmp2;
            tmp1 = a1 / a2;
            tmpi = real2int(tmp1);
            tmp2 = tmpi;
            return (tmp1 - tmp2)*a2;
        }

        real checkPower(real  _test, int64 _power)
        {
            int64   numOfPower;

            if (_test >= _power)
            {
                testLoc = any2int64(_test);
                numOfPower = testLoc div _power;

                if (numOfPower >= 100)
                {
                    temp = numOfPower div 100;
                    returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
                    numOfPower = numOfPower mod 100;
                }
                if (numOfPower >= 20)
                {
                    temp = numOfPower div 10;
                    returntxt = returntxt + ' ' + tenths[temp];
                    numOfPower = numOfPower mod 10;
                }
                if (numOfPower >= 1)
                {
                    returntxt = returntxt + ' ' + ones[numOfPower];
                    numOfPower = numOfPower mod 10;
                }
                switch(_power)
                {
                    case 1000000000000 :
                        returntxt = returntxt + ' ' + trillions;
                        _test = modOperator(_test, 1000000000000.00);
                        break;
                    case 1000000000 :
                        returntxt = returntxt + ' ' + billions;
                        _test = modOperator(_test, 1000000000);
                        break;
                    case 1000000 :
                        returntxt = returntxt + ' ' + millions;
                        _test = modOperator(_test, 1000000);
                        break;
                    case 1000 :
                        returntxt = returntxt + ' ' + thousands;
                        _test = modOperator(_test, 1000);
                        break;
                    case 100 :
                        returntxt = returntxt + ' ' + hundreds;
                        _test = modOperator(_test, 100);
                        break;
                }
            }
            return _test;
        }

        ones[1] = "@SYS26620";
        ones[2] = "@SYS26621";
        ones[3] = "@SYS26622";
        ones[4] = "@SYS26626";
        ones[5] = "@SYS26627";
        ones[6] = "@SYS26628";
        ones[7] = "@SYS26629";
        ones[8] = "@SYS26630";
        ones[9] = "@SYS26631";
        ones[10] = "@SYS26632";
        ones[11] = "@SYS26633";
        ones[12] = "@SYS26634";
        ones[13] = "@SYS26635";
        ones[14] = "@SYS26636";
        ones[15] = "@SYS26637";
        ones[16] = "@SYS26638";
        ones[17] = "@SYS26639";
        ones[18] = "@SYS26640";
        ones[19] = "@SYS26641";

        tenths[1] = 'Not used';
        tenths[2] = "@SYS26643";
        tenths[3] = "@SYS26644";
        tenths[4] = "@SYS26645";
        tenths[5] = "@SYS26646";
        tenths[6] = "@SYS26647";
        tenths[7] = "@SYS26648";
        tenths[8] = "@SYS26649";
        tenths[9] = "@SYS26650";

        hundreds    = "@SYS26651";
        thousands   = "@SYS26652";
        millions    = "@SYS26653";
        billions    = "@SYS26654";
        trillions   = "@SYS101697";

        test = checkPower(test, 1000000000000);
        test = checkPower(test, 1000000000);
        test = checkPower(test, 1000000);
        test = checkPower(test, 1000);
        test = checkPower(test, 100);

        if (test >= 20)
        {
            testLoc = any2int64(test);
            numOfTenths = testLoc div 10;

            returntxt = returntxt + ' ' + tenths[numofTenths];
            numOfTenths = numOfTenths mod 10;
            test = real2int(test) mod 10;
        }
        if (test >= 1)
        {
            numOfTenths = real2int(test);
            returntxt = returntxt + ' ' + ones[numOfTenths];
        }

        if (numOfPennies)
        {
            returntxt = '***' + returntxt + ' ' + "@SYS5534" + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
        }
        else
        {
            returntxt = '***' + returntxt + ' ' + "@SYS5534" + ' ' + '00/100';
        }

        return returntxt;
    }

    static TempStr numeralsToTxt_BR(real _amount, NumeralsToTxtOptions_BR _options = NumeralsToTxtOptions_BR::default())
    {
        str fullText;
        boolean firstWord = true;
        int64 intAmount;
        int64 intCentsAmount;
        int64 sideAmount;
        int64 sidePower;
        int64 partAmount;
        int64 partPower;
        int64 curPartAmount;
        real  centsAmount;

        str prependConnector(str _txt)
        {
            str retVal = _txt;

            if (!firstWord && retVal != "")
            {
                if (_options.parmAndText() && (!(curPartAmount mod partPower) || partPower < 100))
                {
                    retVal = _options.parmAndText() + " " + retVal;
                }
                retVal = " " + retVal;
            }

            return retVal;
        }

        str fixCasing(str _txt)
        {
            str retVal = _txt;

            if (firstWord && _options.parmCapitalFirstWord())
            {
                retVal = str2CapitalWord(retVal);
            }

            return retVal;
        }

        str parsePart(int64 _partAmount)
        {
            str retVal;
            str partText;

            partAmount = _partAmount;

            for (   partPower = 100 ;
            partPower > 0 ;
            partPower = partPower div 10)
            {
                curPartAmount = _partAmount mod (partPower * 10);
                if (curPartAmount div partPower)
                {
                    if (curPartAmount)
                    {
                        if (curPartAmount == 1)
                        {
                            if (firstWord)
                            {
                                partText = _options.parmOneAsTheFirstWord();
                            }
                            else if (sidePower == 1000 && _partAmount == 1)
                            {
                                partText = _options.parmOneAsInOneThousand();
                            }
                            else if (_partAmount == 1)
                            {
                                partText = _options.parmOneAsInOnePart();
                            }
                            else
                            {
                                partText = _options.parmOneRegular();
                            }
                        }
                        else
                        {
                            partText = _options.numberText(curPartAmount);
                        }

                        partText =  fixCasing(prependConnector(partText));
                        firstWord = false;

                        retVal += partText;
                    }

                    if (curPartAmount >= 10 && curPartAmount <= 19)
                    {
                        break;
                    }
                }
            }

            return retVal;
        }

        str parseSide(int64 _sideAmount)
        {
            str     retVal;
            int64   curAmount = _sideAmount;

            sideAmount = _sideAmount;
            for (   sidePower = 1000000000 ;
            sidePower > 0 ;
            sidePower = sidePower div 1000)
            {
                curAmount = _sideAmount div sidePower;

                if (curAmount)
                {
                    retVal += parsePart(curAmount);
                    if (sidePower > 1)
                    {
                        retVal += strFmt(" %1", _options.powerText(_sideAmount));
                    }
                }

                _sideAmount = _sideAmount mod sidePower;
            }

            return retVal;
        }

        intAmount = real2int(_amount);
        fullText = parseSide(intAmount);
        if (fullText)
        {
            fullText += " " + _options.currencyText(intAmount);
        }

        if (_options.fixedTextForCents() != "")
        {
            fullText += _options.fixedTextForCents();
        }
        else
        {
            centsAmount = (_amount - sideAmount) * 100;
            intCentsAmount = real2int(centsAmount);
            if (intCentsAmount)
            {
                fullText += strFmt("%1 %2", parseSide(intCentsAmount), _options.currencyCentsText(intCentsAmount));
            }
        }

        return fullText;
    }

    static TempStr numeralsToTxt_EN(real _num)
    {
        int     numOfPennies = real2int(decRound(frac(_num), 2) * 100) mod 100;
        real    test         = _num - frac(_num);

        int64   numOfTenths;
        str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;

        int64   temp;
        str 200 returntxt;
        int64   testLoc;

        real modOperator(real a1, real a2)
        {
            int tmpi;
            real tmp1, tmp2;
            tmp1 = a1 / a2;
            tmpi = real2int(tmp1);
            tmp2 = tmpi;
            return (tmp1 - tmp2)*a2;
        }

        real checkPower(real  _test, int64 _power)
        {
            int64   numOfPower;

            if (_test >= _power)
            {
                testLoc = any2Int64(_test);
                numOfPower = testLoc div _power;
                if (numOfPower >= 100)
                {
                    temp = numOfPower div 100;
                    returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
                    numOfPower = numOfPower mod 100;
                }
                if (numOfPower >= 20)
                {
                    temp = numOfPower div 10;
                    returntxt = returntxt + ' ' + tenths[temp];
                    numOfPower = numOfPower mod 10;
                }
                if (numOfPower >= 1)
                {
                    returntxt = returntxt + ' ' + ones[numOfPower];
                    numOfPower = numOfPower mod 10;
                }
                switch(_power)
                {
                    case 1000000000000 :
                        returntxt = returntxt + ' ' + trillions;
                        _test = modOperator(_test, 1000000000000.00);
                        break;
                    case 1000000000 :
                        returntxt = returntxt + ' ' + billions;
                        _test = modOperator(_test, 1000000000);
                        break;
                    case 1000000 :
                        returntxt = returntxt + ' ' + millions;
                        _test = modOperator(_test, 1000000);
                        break;
                    case 1000 :
                        returntxt = returntxt + ' ' + thousands;
                        _test = modOperator(_test, 1000);
                        break;
                    case 100 :
                        returntxt = returntxt + ' ' + hundreds;
                        _test = modOperator(_test, 100);
                        break;
                }
            }
            return _test;
        }

        #Define.text_1('One')
        #Define.text_2('Two')
        #Define.text_3('Three')
        #Define.text_4('Four')
        #Define.text_5('Five')
        #Define.text_6('Six')
        #Define.text_7('Seven')
        #Define.text_8('Eight')
        #Define.text_9('Nine')
        #Define.text_10('Ten')
        #Define.text_11('Eleven')
        #Define.text_12('Twelve')
        #Define.text_13('Thirteen')
        #Define.text_14('Fourteen')
        #Define.text_15('Fifteen')
        #Define.text_16('Sixteen')
        #Define.text_17('Seventeen')
        #Define.text_18('Eighteen')
        #Define.text_19('Nineteen')
        #Define.text_20('Twenty')
        #Define.text_30('Thirty')
        #Define.text_40('Forty')
        #Define.text_50('Fifty')
        #Define.text_60('Sixty')
        #Define.text_70('Seventy')
        #Define.text_80('Eighty')
        #Define.text_90('Ninety')
        #Define.text_100('Hundred')
        #Define.text_1000('Thousand')
        #Define.text_1000000('Million')
        #Define.text_1000000000('Billion')
        #Define.text_1000000000000('Trillion')
        #Define.text_and('and')

        ones[1] = #text_1;
        ones[2] = #text_2;
        ones[3] = #text_3;
        ones[4] = #text_4;
        ones[5] = #text_5;
        ones[6] = #text_6;
        ones[7] = #text_7;
        ones[8] = #text_8;
        ones[9] = #text_9;
        ones[10] = #text_10;
        ones[11] = #text_11;
        ones[12] = #text_12;
        ones[13] = #text_13;
        ones[14] = #text_14;
        ones[15] = #text_15;
        ones[16] = #text_16;
        ones[17] = #text_17;
        ones[18] = #text_18;
        ones[19] = #text_19;

        tenths[1] = 'Not used';
        tenths[2] = #text_20;
        tenths[3] = #text_30;
        tenths[4] = #text_40;
        tenths[5] = #text_50;
        tenths[6] = #text_60;
        tenths[7] = #text_70;
        tenths[8] = #text_80;
        tenths[9] = #text_90;

        hundreds    = #text_100;
        thousands   = #text_1000;
        millions    = #text_1000000;
        billions    = #text_1000000000;
        trillions   = #text_1000000000000;

        test = checkPower(test, 1000000000000);
        test = checkPower(test, 1000000000);
        test = checkPower(test, 1000000);
        test = checkPower(test, 1000);
        test = checkPower(test, 100);

        if (test >= 20)
        {
            testLoc = any2int64(test);
            numOfTenths = testLoc div 10;
            returntxt = returntxt + ' ' + tenths[numofTenths];
            numOfTenths = numOfTenths mod 10;
            test = real2int(test) mod 10;
        }
        if (test >= 1)
        {
            numOfTenths = real2int(test);
            returntxt = returntxt + ' ' + ones[numOfTenths];
        }

        if (numOfPennies)
        {
            returntxt = '***' + returntxt + ' ' + #text_and + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
        }
        else
        {
            returntxt = '***' + returntxt + ' ' + #text_and + ' ' + '00/100';
        }

        return returntxt;
    }

    static TempStr numeralsToTxt_ES(real             _num,
                                    GenderMaleFemale _gender          = GenderMaleFemale::Female,
                                    boolean          _enclose         = true,
                                    str  _currencyCodeISO = '',
                                    boolean          _isMexican       = false,
                                    boolean          _isCheck         = false)
    {
        int     numOfPennies = any2int(decRound(frac(_num), 2) * 100) mod 100;
        real    test         = _num - frac(_num);
        real    auxtest = 0;

        real    numOfTenths ;
        str 20  ones[19], twenties[9], tenths[9], muchhundreds, hundreds, thousands, muchmillions, millions, billions, muchhunmillions, trillions, muchtrillions;

        str 200 returntxt;

        str     cpStr;
        int64   cpInt;

        #Define.text_1_male('Uno')
        #Define.text_1_female('Una')
        #Define.text_2('Dos')
        #Define.text_3('Tres')
        #Define.text_4('Cuatro')
        #Define.text_5('Cinco')
        #Define.text_6('Seis')
        #Define.text_7('Siete')
        #Define.text_8('Ocho')
        #Define.text_9('Nueve')
        #Define.text_10('Diez')
        #Define.text_11('Once')
        #Define.text_12('Doce')
        #Define.text_13('Trece')
        #Define.text_14('Catorce')
        #Define.text_15('Quince')
        #Define.text_16('Dieciseis')
        #Define.text_17('Diecisiete')
        #Define.text_18('Dieciocho')
        #Define.text_19('Diecinueve')

        #Define.text_20('Veinte')

        #Define.text_21_female('Veintiuna')
        #Define.text_21_male('Veintiun')
        #Define.text_22('Veintidos')
        #Define.text_23('Veintitres')
        #Define.text_24('Veinticuatro')
        #Define.text_25('Veinticinco')
        #Define.text_26('Veintiseis')
        #Define.text_27('Veintisiete')
        #Define.text_28('Veintiocho')
        #Define.text_29('Veintinueve')

        #Define.text_30('Treinta')
        #Define.text_40('Cuarenta')
        #Define.text_50('Cincuenta')
        #Define.text_60('Sesenta')
        #Define.text_70('Setenta')
        #Define.text_80('Ochenta')
        #Define.text_90('Noventa')

        #Define.text_100('Cien')
        #Define.text_100_female('cientas')
        #Define.text_100_male('cientos')
        #Define.text_100_much('Cientos')
        #Define.text_100_begin('Ciento')

        #Define.text_500_female('Quinientas')
        #Define.text_500_male('Quinientos')
        
        #Define.text_7_begin('Sete')
        #Define.text_9_begin('Nove')

        #Define.text_1000('Mil')

        #Define.text_1000000('Millon')
        #Define.text_1000000_much('Millones')
        #Define.text_1000000000('Mil millones')
        #Define.text_1000000000000('Trillón')
        #Define.text_1000000000000_much('Trillónes')

        #Define.text_and('y')
        #Define.text_with('con')
        
        #Define.text_cents_GBP(' peniques')
        #Define.text_cents_USD(' centavos')
        #Define.text_cents_EUR(' centimos')

        #Define.currencyCodeISO_UK('GBP')
        #Define.currencyCodeISO_USA('USD')
        
        #Define.text_print_entire_cents('00/100')
        #Define.text_print_cents('/100')
        #Define.text_pesos('pesos')

        str centsName()
        {
            str 9 centText;
            switch (_currencyCodeISO)
            {
                case #currencyCodeISO_UK:
                    centText = #text_cents_GBP;
                    break;
                case #currencyCodeISO_USA:
                    centText = #text_cents_USD;
                    break;
                default:
                    centText = #text_cents_EUR;
            }
            return centText;
        }

        ones[1] = #text_1_male;
        ones[2] = #text_2;
        ones[3] = #text_3;
        ones[4] = #text_4;
        ones[5] = #text_5;
        ones[6] = #text_6;
        ones[7] = #text_7;
        ones[8] = #text_8;
        ones[9] = #text_9;
        ones[10] = #text_10;
        ones[11] = #text_11;
        ones[12] = #text_12;
        ones[13] = #text_13;
        ones[14] = #text_14;
        ones[15] = #text_15;
        ones[16] = #text_16;
        ones[17] = #text_17;
        ones[18] = #text_18;
        ones[19] = #text_19;

        twenties[1] = _gender == GenderMaleFemale::Female ? #text_21_female: #text_21_male;
        twenties[2] = #text_22;
        twenties[3] = #text_23;
        twenties[4] = #text_24;
        twenties[5] = #text_25;
        twenties[6] = #text_26;
        twenties[7] = #text_27;
        twenties[8] = #text_28;
        twenties[9] = #text_29;

        tenths[1] = ''; // Not used
        tenths[2] = #text_20;
        tenths[3] = #text_30;
        tenths[4] = #text_40;
        tenths[5] = #text_50;
        tenths[6] = #text_60;
        tenths[7] = #text_70;
        tenths[8] = #text_80;
        tenths[9] = #text_90;

        hundreds    = #text_100;

        muchhundreds = _gender == GenderMaleFemale::Female ? #text_100_female: #text_100_male;

        muchhunmillions = #text_100_much;

        thousands   = #text_1000;
        millions    = #text_1000000;
        muchmillions = #text_1000000_much;

        billions    = #text_1000000000;
        trillions   = #text_1000000000000;
        muchtrillions = #text_1000000000000_much;

        [cpInt, cpStr] = checkPower(any2int64(test), 1000000000000, _gender, _isMexican);
        test = str2num(int642str(cpInt));
        if (cpStr)
        {
            returntxt = returntxt + ' ' + cpStr;
        }

        [cpInt, cpStr] = checkPower(any2int64(test), 1000000000, _gender, _isMexican);
        test = str2num(int642str(cpInt));
        if (cpStr)
        {
            returntxt = returntxt + ' ' + cpStr;
        }

        [cpInt, cpStr] = checkPower(any2int64(test), 1000000, _gender, _isMexican);
        test = str2num(int642str(cpInt));
        if (cpStr)
        {
            returntxt = returntxt + ' ' + cpStr;
        }

        [cpInt, cpStr] = checkPower(any2int64(test), 1000, _gender, _isMexican);
        test = str2num(int642str(cpInt));
        if (cpStr)
        {
            returntxt = returntxt + ' ' + cpStr;
        }

        [cpInt, cpStr] = checkPower(any2int64(test), 100, _gender, _isMexican);
        test = str2num(int642str(cpInt));
        if (cpStr)
        {
            returntxt = returntxt + ' ' + cpStr;
        }

        if (test >= 20)
        {
            numOfTenths = real2int(test) div 10;
            if (test > 20 && test < 30)
            {
                returntxt = returntxt + ' ' + twenties[test-20];
            }
            else
            {
                returntxt = returntxt + ' ' + tenths[numofTenths];
            }
            numOfTenths = real2int(numOfTenths) mod 10;
            auxtest = test;
            test = real2int(test) mod 10;
        }

        if ((test >= 1) && !(auxtest > 20 && auxtest < 30))
        {
            numOfTenths = test;
            if (numOfTenths == 1)
            {
                if (auxtest == 0)
                {
                    returntxt = returntxt + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
                }
                else
                {
                    returntxt = returntxt + ' ' + #text_and + ' ' + (_gender == GenderMaleFemale::Female ? #text_1_female : #text_1_male);
                }
            }
            else
            {
                if (( auxtest > 20 ))
                {
                    returntxt = returntxt + ' ' + #text_and + ' ' + ones[numOfTenths];
                }
                else
                {
                    returntxt = returntxt + ' ' + ones[numOfTenths];
                }
            }
        }

        auxtest = 0;

        if (_isMexican)
        {
            if (_isCheck) //For checks, need to insert pesos into the string.
            {
                if (numOfPennies < 0.5)
                {
                    returntxt = returntxt + ' ' + #text_pesos + ' ' + #text_print_entire_cents;
                }
                else
                {
                    if (numOfPennies >= 0.5 && numOfPennies < 9.5)
                    {
                        returntxt = returntxt + ' ' + #text_pesos + ' 0' + num2str(numOfPennies,1,0,1,0) + #text_print_cents;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + #text_pesos + ' ' + num2str(numOfPennies,2,0,1,0) + #text_print_cents;
                    }
                }

                returntxt = strUpr(subStr(returntxt, 1, 2)) + strLwr(subStr(returntxt, 3, strLen(returntxt) - 2));

                if(_enclose)
                {
                    returntxt = '***' + returntxt + '***' ;
                }
            }
            else
            {
                if (numOfPennies < 0.5)
                {
                    returntxt = returntxt + ' ' + #text_print_entire_cents;
                }
                else
                {
                    if (numOfPennies >= 0.5 && numOfPennies < 9.5)
                    {
                        returntxt = returntxt + ' 0' + num2str(numOfPennies,1,0,1,0) + #text_print_cents;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + num2str(numOfPennies,2,0,1,0) + #text_print_cents;
                    }
                }

                returntxt = strUpr(subStr(returntxt, 1, 2)) + strLwr(subStr(returntxt, 3, strLen(returntxt) - 2));
                
                if(_enclose)
                {
                    returntxt = '***' + returntxt + '***' ;
                }
            }
        }
        else
        {
            if (numOfPennies)
            {
                returntxt = strUpr(returntxt) + ' ' + #text_with + strUpr(numeralsToTxt_ES(numOfPennies, GenderMaleFemale::Male, false))+ centsName();
            }
            if(_enclose)
            {
                returntxt = '***' + strUpr(returntxt) + '***';
            }
        }

        if (subStr(returntxt, 1, 4) == '*** ')
        {
            returntxt = strDel(returntxt, 4, 1);
        }
        if (subStr(returntxt, strLen(returntxt)-3, 4) == ' ***')
        {
            returntxt = strDel(returntxt, strLen(returntxt) -3,1);
        }
        
        return returntxt;
    }

    static TempStr numeralsToTxt_FR(real _num, boolean _isFrenchCheck = false)
    {
        int     numOfPennies = any2int(decRound(frac(_num), 2) * 100) mod 100;
        real    test         = _num - frac(_num);

        int64   numOfTens, seventyNum, ninetyNum;
        str 25  ones[19], tens[9], seventies[9], nineties[9];
        str 10  zero, hundred, hundreds, thousands, million, millions, billion, billions, trillion, trillions;

        str 2   pennies;
        str 5   currency;

        int64   temp;
        str 200 returntxt;
        int64   testLoc;

        #Define.euro('euro')
        #Define.euros('euros')
        #Define.text_0('Zéro')
        #Define.text_1('Un')
        #Define.text_2('Deux')
        #Define.text_3('Trois')
        #Define.text_4('Quatre')
        #Define.text_5('Cinq')
        #Define.text_6('Six')
        #Define.text_7('Sept')
        #Define.text_8('Huit')
        #Define.text_9('Neuf')
        #Define.text_10('Dix')
        #Define.text_11('Onze')
        #Define.text_12('Douze')
        #Define.text_13('Treize')
        #Define.text_14('Quatorze')
        #Define.text_15('Quinze')
        #Define.text_16('Seize')
        #Define.text_17('Dix-Sept')
        #Define.text_18('Dix-Huit')
        #Define.text_19('Dix-Neuf')
        #Define.text_20('Vingt')
        #Define.text_30('Trente')
        #Define.text_40('Quarante')
        #Define.text_50('Cinquante')
        #Define.text_60('Soixante')
        #Define.text_70('Soixante-Dix')
        #Define.text_71('Soixante Et Onze')
        #Define.text_72('Soixante-Douze')
        #Define.text_73('Soixante-Treize')
        #Define.text_74('Soixante-Quatorze')
        #Define.text_75('Soixante-Quinze')
        #Define.text_76('Soixante-Seize')
        #Define.text_77('Soixante-Dix-Sept')
        #Define.text_78('Soixante-Dix-Huit')
        #Define.text_79('Soixante-Dix-Neuf')
        #Define.text_80('Quatre-Vingts')
        #Define.text_81('Quatre-Vingt-Un')
        #Define.text_80s('Quatre-Vingt')
        #Define.text_90('Quatre-Vingt-Dix')
        #Define.text_91('Quatre-Vingt-Onze')
        #Define.text_92('Quatre-Vingt-Douze')
        #Define.text_93('Quatre-Vingt-Treize')
        #Define.text_94('Quatre-Vingt-Quatorze')
        #Define.text_95('Quatre-Vingt-Quinze')
        #Define.text_96('Quatre-Vingt-Seize')
        #Define.text_97('Quatre-Vingt-Dix-Sept')
        #Define.text_98('Quatre-Vingt-Dix-Huit')
        #Define.text_99('Quatre-Vingt-Dix-Neuf')
        #Define.text_100('Cent')
        #Define.text_100s('Cents')
        #Define.text_1000('Mille')
        #Define.text_1000000('Million')
        #Define.text_1000000s('Millions')
        #Define.text_1000000000('Millard')
        #Define.text_1000000000s('Millards')
        #Define.text_1000000000000('Trillion')
        #Define.text_1000000000000s('Trillions')
        #Define.text_and('Et')
        #Define.text_cents('Cts')

        real modOperator(real a1, real a2)
        {
            int  tmpi;
            real tmp1, tmp2;
            tmp1 = a1 / a2;
            tmpi = real2int(tmp1);
            tmp2 = tmpi;
            return (tmp1 - tmp2)*a2;
        }

        str 25 buildHundredString(real _number, int64 _power)
        {
            str 25      hundredStrTxt;
            boolean     use_And = false;
            ;

            // 90-99
            if (_number >= 90 && _number <= 99)
            {
                ninetyNum = real2int(_number) mod 90;
                if (ninetyNum != 0)
                {
                    hundredStrTxt = hundredStrTxt + ' ' + nineties[ninetyNum];
                }
                else
                {
                    numOfTens = real2int(_number) div 10;
                    hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
                }
                _number = 0;
            }

            // 81
            if (_number == 81)
            {
                hundredStrTxt = hundredStrTxt + ' ' + #text_81;
                _number = 0;
            }

            // 80
            if (_number == 80)
            {
                hundredStrTxt = hundredStrTxt + ' ' + #text_80;
                _number = 0;
            }

            // 70-79
            if (_number >= 70 && _number <= 79)
            {
                seventyNum = real2int(_number) mod 70;
                if (seventyNum != 0)
                {
                    hundredStrTxt = hundredStrTxt + ' ' + seventies[seventyNum];
                }
                else
                {
                    numOfTens = _number div 10;
                    hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
                }
                _number = 0;
            }

            // 20-69, 82-89
            if (_number >= 20)
            {
                numOfTens = _number div 10;
                hundredStrTxt = hundredStrTxt + ' ' + tens[numOfTens];
                numOfTens = numOfTens mod 10;
                _number = real2int(_number) mod 10;

                if (_number >= 2 && _number <= 9)
                {
                    hundredStrTxt = hundredStrTxt + '-';
                }

                if (_number == 1)
                {
                    use_And = true;
                }
            }

            // 2-19
            if (_number >= 2)
            {
                numOfTens = real2int(_number);

                // If the last character in the hundredStrTxt string is a '-'
                if (strCmp(subStr(hundredStrTxt, strLen(hundredStrTxt), 1), '-') == 0)
                {
                    hundredStrTxt = hundredStrTxt + ones[numOfTens];
                }
                else
                {
                    hundredStrTxt = hundredStrTxt + ' ' + ones[numOfTens];
                }
            }

            // 1
            if (_number == 1 && (_power != 100))
            {
                if (use_And)
                {
                    hundredStrTxt = hundredStrTxt + ' ' + #text_and + ' ' + #text_1;
                }
                else
                {
                    hundredStrTxt = hundredStrTxt + ' ' + #text_1;
                }
            }

            // 0
            // Only print 'Zero' if no other non-penny number has been printed
            if ((_number == 0) && (_power == 0) && (returntxt == "") && (hundredStrTxt == ""))
            {
                hundredStrTxt = hundredStrTxt + ' ' + #text_0;
            }

            return hundredStrTxt;
        }

        real checkPower(real  _test, int64 _power)
        {
            int64   numOfPower;

            if (_test >= _power)
            {
                // Build the 'over one hundred' portion of the string for each power
                testLoc = any2int64(_test);
                numOfPower = testLoc div _power;
                if (numOfPower >= 100)
                {
                    temp = numOfPower div 100;
                    // If it is 'Cent', no 'Un' is needed
                    if (temp == 1)
                    {
                        returntxt = returntxt + ' ' + hundred;
                    }
                    else
                    {
                        returntxt = returntxt + ' ' + ones[temp] + ' ' + hundred;
                    }
                    numOfPower = numOfPower mod 100;
                }

                // Make sure that 'un' isn't printed in front of 'mille' for numbers such as 3001000 or 1000
                if ( !((real2int(_test / _power) == 1) && (_power == 1000)) )
                {
                    // Build the 'under one hundred' portion of the string for each power
                    returntxt = returntxt + buildHundredString(any2real(numOfPower), _power);
                }

                switch(_power)
                {
                    case 1000000000000 :    // Trillion
                        {
                            if ((_test / _power) == 1)
                            {
                                returntxt = returntxt + ' ' + trillion;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + trillions;
                            }
                            _test = modOperator(_test, 1000000000000.00);
                            break;
                        }
                    case 1000000000 :       // Billion
                        {
                            if ((_test / _power) == 1)
                            {
                                returntxt = returntxt + ' ' + billion;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + billions;
                            }
                            _test = modOperator(_test, 1000000000);
                            break;
                        }
                    case 1000000 :          // Million
                        {
                            if ((_test / _power) == 1)
                            {
                                returntxt = returntxt + ' ' + million;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + millions;
                            }
                            _test = modOperator(_test, 1000000);
                            break;
                        }
                    case 1000 :             // Thousands
                        {
                            returntxt = returntxt + ' ' + thousands;
                            _test = modOperator(_test, 1000);
                            break;
                        }
                    case 100 :              // Hundreds
                        {
                            if ((real2int(test) mod 100 == 0) && (numOfPower != 1))
                            {
                                returntxt = returntxt + ' ' + hundreds;
                            }
                            else
                            {
                                returntxt = returntxt + ' ' + hundred;
                            }
                            _test = modOperator(_test, 100);
                            break;
                        }
                }
            }
            return _test;
        }

        ones[1] = #text_1;
        ones[2] = #text_2;
        ones[3] = #text_3;
        ones[4] = #text_4;
        ones[5] = #text_5;
        ones[6] = #text_6;
        ones[7] = #text_7;
        ones[8] = #text_8;
        ones[9] = #text_9;
        ones[10] = #text_10;
        ones[11] = #text_11;
        ones[12] = #text_12;
        ones[13] = #text_13;
        ones[14] = #text_14;
        ones[15] = #text_15;
        ones[16] = #text_16;
        ones[17] = #text_17;
        ones[18] = #text_18;
        ones[19] = #text_19;

        tens[1] = 'Not used';
        tens[2] = #text_20;
        tens[3] = #text_30;
        tens[4] = #text_40;
        tens[5] = #text_50;
        tens[6] = #text_60;
        tens[7] = #text_70;
        tens[8] = #text_80s;
        tens[9] = #text_90;

        seventies[1] = #text_71;
        seventies[2] = #text_72;
        seventies[3] = #text_73;
        seventies[4] = #text_74;
        seventies[5] = #text_75;
        seventies[6] = #text_76;
        seventies[7] = #text_77;
        seventies[8] = #text_78;
        seventies[9] = #text_79;

        nineties[1] = #text_91;
        nineties[2] = #text_92;
        nineties[3] = #text_93;
        nineties[4] = #text_94;
        nineties[5] = #text_95;
        nineties[6] = #text_96;
        nineties[7] = #text_97;
        nineties[8] = #text_98;
        nineties[9] = #text_99;

        zero        = #text_0;
        hundred     = #text_100;
        hundreds    = #text_100s;
        thousands   = #text_1000;
        million     = #text_1000000;
        millions    = #text_1000000s;
        billion     = #text_1000000000;
        billions    = #text_1000000000s;
        trillion    = #text_1000000000000;
        trillions   = #text_1000000000000s;

        // Builds the string from the highest power digits on down, returntxt is updated in each call
        //  Note: These must be called in decreasing order of powers
        test = checkPower(test, 1000000000000);
        test = checkPower(test, 1000000000);
        test = checkPower(test, 1000000);
        test = checkPower(test, 1000);
        test = checkPower(test, 100);

        returntxt = strLTrim(returntxt) + buildHundredString(test, 0);

        if(_isFrenchCheck)
        {
            if (_num < 2)
            {
                currency = #euro;
            }
            else
            {
                currency = #euros;
            }
        }

        // Adds on the penny portion of the string
        if (numOfPennies)
        {
            if(_isFrenchCheck)
            {
                pennies =  num2str(numOfPennies,0,0,0,0);
                if (strLen(pennies) == 1)
                {
                    pennies = int2str(0) + pennies;
                }

                returntxt = '*' + returntxt + ' ' + currency + ' ' + #text_and + ' ' + pennies + ' ' +  #text_cents + '*';
            }
            else
            {
                returntxt = '***' + returntxt + ' ' + #text_and + ' ' + num2str(numOfPennies,0,0,0,0) + '/100';
            }
        }
        else
        {
            if(_isFrenchCheck)
            {
                returntxt = '*' + returntxt + ' ' + currency + '*' ;
            }
            else
            {
                returntxt = '***' + returntxt + ' ' + #text_and + ' ' + '00/100';
            }
        }

        if(_isFrenchCheck)
        {
            return strUpr(returntxt);
        }
        else
        {
            return returntxt;
        }
    }

    /// <summary>
    /// Convert numerals to Hindi format text.
    /// </summary>
    /// <param name="_num">
    /// The numeral to be converted.
    /// </param>
    /// <returns>
    /// The converted string.
    /// </returns>
    static TempStr numeralsToTxt_IN(real _num)
    {
        int     numOfPennies = any2int(decRound(frac(_num), 2) * 100) mod 100;
        real    amount         = _num - frac(_num);
        int     numOfTenths;
        str 20  ones[19], tenths[9], hundreds, thousands, millions, billions, trillions;

        int64   temp;
        str 200 returntxt;
        int64   amountInInt64;
        boolean checkStatus = false;
        #define.paise("paise")

        real modOperator(real a1, real a2)
        {
            int tmpi;
            real tmp1, tmp2;
            tmp1 = a1 / a2;
            tmpi = real2int(tmp1);
            tmp2 = tmpi;
            return (tmp1 - tmp2)*a2;
        }

        real checkPower(real  _amount, int64 _power)
        {
            int64   numOfPower;

            if (_amount >= _power)
            {
                amountInInt64 = real2double(_amount);
                numOfPower = amountInInt64 div _power;
                if (numOfPower >= 100)
                {
                    temp = numOfPower div 100;
                    returntxt = returntxt + ' ' + ones[temp] + ' ' + hundreds;
                    numOfPower = numOfPower mod 100;
                }
                if (numOfPower >= 20)
                {
                    temp = numOfPower div 10;
                    returntxt = returntxt + ' ' + tenths[temp];
                    numOfPower = numOfPower mod 10;
                }
                if (numOfPower >= 1)
                {
                    returntxt = returntxt + ' ' + ones[numOfPower];
                    numOfPower = numOfPower mod 10;
                }
                switch(_power)
                {
                    case 1000000000000:
                        returntxt = returntxt + ' ' + trillions;
                        _amount = modOperator(_amount, 1000000000000.00);
                        break;
                    case 1000000000:
                        returntxt = returntxt + ' ' + billions;
                        _amount = modOperator(_amount, 1000000000);
                        break;
                    case 1000000:
                        returntxt = returntxt + ' ' + millions;
                        _amount = modOperator(_amount, 1000000);
                        break;
                    case 1000:
                        returntxt = returntxt + ' ' + thousands;
                        _amount = modOperator(_amount, 1000);
                        break;
                    case 100:
                        returntxt = returntxt + ' ' + hundreds;
                        _amount = modOperator(_amount, 100);
                        break;
                    default:
                        break;
                }
            }
            return _amount;
        }

        ;

        ones[1] = "@SYS26620";
        ones[2] = "@SYS26621";
        ones[3] = "@SYS26622";
        ones[4] = "@SYS26626";
        ones[5] = "@SYS26627";
        ones[6] = "@SYS26628";
        ones[7] = "@SYS26629";
        ones[8] = "@SYS26630";
        ones[9] = "@SYS26631";
        ones[10] = "@SYS26632";
        ones[11] = "@SYS26633";
        ones[12] = "@SYS26634";
        ones[13] = "@SYS26635";
        ones[14] = "@SYS26636";
        ones[15] = "@SYS26637";
        ones[16] = "@SYS26638";
        ones[17] = "@SYS26639";
        ones[18] = "@SYS26640";
        ones[19] = "@SYS26641";

        tenths[1] = 'Not used';
        tenths[2] = "@SYS26643";
        tenths[3] = "@SYS26644";
        tenths[4] = "@SYS26645";
        tenths[5] = "@SYS26646";
        tenths[6] = "@SYS26647";
        tenths[7] = "@SYS26648";
        tenths[8] = "@SYS26649";
        tenths[9] = "@SYS26650";

        hundreds    = "@SYS26651";
        thousands   = "@SYS26652";
        millions    = "@SYS26653";
        billions    = "@SYS26654";
        trillions   = "@SYS101697";


        amount = checkPower(amount, 1000000000000);
        amount = checkPower(amount, 1000000000);
        amount = checkPower(amount, 1000000);
        amount = checkPower(amount, 1000);
        amount = checkPower(amount, 100);

        if (amount >= 20)
        {
            numOfTenths = real2int(amount) div 10;
            returntxt = returntxt + ' ' + tenths[numofTenths];
            numOfTenths = numOfTenths mod 10;
            amount = real2int(amount) mod 10;
        }
        if (amount >= 1)
        {
            numOfTenths = real2int(amount);
            returntxt = returntxt + ' ' + ones[numOfTenths];
        }

        if (numOfPennies >= 20)
        {
            numOfTenths = numOfPennies div 10;
            returntxt =  returntxt + ' '+"@SYS5534" +' '+ tenths[numofTenths];
            numOfTenths = numOfTenths mod 10;
            numOfPennies = numOfPennies mod 10;
            checkStatus = true;
        }
        if (numOfPennies >= 1)
        {
            numOfTenths = real2int(numOfPennies);
            returntxt = checkStatus == true ? returntxt + ' ' + ones[numOfTenths] : returntxt + ' '+"@SYS5534" +' ' + ones[numOfTenths];
            checkStatus = true;
        }
        if (numOfPennies == 0 && !checkStatus)
        {
            returntxt = returntxt + ' ' + "@SYS5534"+' '+"@SYS2068";
        }

        return   returntxt + ' ' + #paise;

    }

    static TempStr numeralsToTxt_NL(real _num, boolean _enclose = true)
    {
        /*
            Given a real number, this function will round the decimal places to 2 decimal places,
            translate that number into Dutch and return that value.  Negative numbers will
            return the traslation for the positive number (absolute value).  The maximum
            number this function will translate is 999,999,999,999,999.
            */
        int      numOfPennies = any2int(decRound(frac(abs(_num)), 2) * 100) mod 100;
        int64    numbOfDollars = any2int64(abs(_num) - frac(abs(_num)));

        int64   temp;
        str 300 returntxt;
        str 25  lessThan100[99], zero, hundred, thousand, million, billion, trillion, and, hundredth, oneHundredth;
        str 1 space;

        //Define Macros
        #Define.Text0('Nul')                        // 0 - Zero
        #Define.Text1('Een')                        // 1 - One
        #Define.Text2('Twee')                       // 2 - Two
        #Define.Text3('Drie')                       // 3 - Three
        #Define.Text4('Vier')                       // 4 - Four
        #Define.Text5('Vijf')                       // 5 - Five
        #Define.Text6('Zes')                        // 6 - Six
        #Define.Text7('Zeven')                      // 7 - Seven
        #Define.Text8('Acht')                       // 8 - Eight
        #Define.Text9('Negen')                      // 9 - Nine
        #Define.Text10('Tien')                      // 10 - Ten
        #Define.Text11('Elf')                       // 11 - Eleven
        #Define.Text12('Twaalf')                    // 12 - Twelve
        #Define.Text13('Dertien')                   // 13 - Thirteen
        #Define.Text14('Veertien')                  // 14 - Fourteen
        #Define.Text15('Vijftien')                  // 15 - Fifteen
        #Define.Text16('Zestien')                   // 16 - Sixteen
        #Define.Text17('Zeventien')                 // 17 - Seventeen
        #Define.Text18('Achttien')                  // 18 - Eighteen
        #Define.Text19('Negentien')                 // 19 - Nineteen
        #Define.Text20('Twintig')                   // 20 - Twenty
        #Define.Text21('Eenentwintig')              // 21 - Twenty One
        #Define.Text22('Tweeëntwintig')             // 22 - Twenty Two
        #Define.Text23('Drieëntwintig')             // 23 - Twenty Three
        #Define.Text24('Vierentwintig')             // 24 - Twenty Four
        #Define.Text25('Vijfentwintig')             // 25 - Twenty Five
        #Define.Text26('Zesentwintig')              // 26 - Twenty Six
        #Define.Text27('Zevenentwintig')            // 27 - Twenty Seven
        #Define.Text28('Achtentwintig')             // 28 - Twenty Eight
        #Define.Text29('Negenentwintig')            // 29 - Twenty Nine
        #Define.Text30('Dertig')                    // 30 - Thirty
        #Define.Text31('Eenendertig')               // 31 - Thirty One
        #Define.Text32('Tweeëndertig')              // 32 - Thirty Two
        #Define.Text33('Drieëndertig')              // 33 - Thirty Three
        #Define.Text34('Vierendertig')              // 34 - Thirty Four
        #Define.Text35('Vijfendertig')              // 35 - Thirty Five
        #Define.Text36('Zesendertig')               // 36 - Thirty Six
        #Define.Text37('Zevenendertig')             // 37 - Thirty Seven
        #Define.Text38('Achtendertig')              // 38 - Thirty Eight
        #Define.Text39('Negenendertig')             // 39 - Thirty Nine
        #Define.Text40('Veertig')                   // 40 - Forty
        #Define.Text41('Eenenveertig')              // 41 - Forty One
        #Define.Text42('Tweeënveertig')             // 42 - Forty Two
        #Define.Text43('Drieënveertig')             // 43 - Forty Three
        #Define.Text44('Vierenveertig')             // 44 - Forty Four
        #Define.Text45('Vijfenveertig')             // 45 - Forty Five
        #Define.Text46('Zesenveertig')              // 46 - Forty Six
        #Define.Text47('Zevenenveertig')            // 47 - Forty Sept
        #Define.Text48('Achtenveertig')             // 48 - Forty Eight
        #Define.Text49('Negenenveertig')            // 49 - Forty Nine
        #Define.Text50('Vijftig')                   // 50 - Fifty
        #Define.Text51('Eenenvijftig')              // 51 - Fifty One
        #Define.Text52('Tweeënvijftig')             // 52 - Fifty Deux
        #Define.Text53('Drieënvijftig')             // 53 - Fifty Three
        #Define.Text54('Vierenvijftig')             // 54 - Fifty Four
        #Define.Text55('Vijfenvijftig')             // 55 - Fifty Five
        #Define.Text56('Zesenvijftig')              // 56 - Fifty Six
        #Define.Text57('Zevenenvijftig')            // 57 - Fifty Seven
        #Define.Text58('Achtenvijftig')             // 58 - Fifty Eight
        #Define.Text59('Negenenvijftig')            // 59 - Fifty Nine
        #Define.Text60('Zestig')                    // 60 - Sixty
        #Define.Text61('Eenenzestig')               // 61 - Sixty One
        #Define.Text62('Tweeënzestig')              // 62 - Sixty Two
        #Define.Text63('Drieënzestig')              // 63 - Sixty Three
        #Define.Text64('Vierenzestig')              // 64 - Sixty Four
        #Define.Text65('Vijfenzestig')              // 65 - Sixty Five
        #Define.Text66('Zesenzestig')               // 66 - Sixty Six
        #Define.Text67('Zevenenzestig')             // 67 - Sixty Seven
        #Define.Text68('Achtenzestig')              // 68 - Sixty Eight
        #Define.Text69('Negenenzestig')             // 69 - Sixty Nine
        #Define.Text70('Zeventig')                  // 70 - Seventy
        #Define.Text71('Eenenzeventig')             // 71 - Seventy One
        #Define.Text72('Tweeënzeventig')            // 72 - Seventy Two
        #Define.Text73('Drieënzeventig')            // 73 - Seventy Three
        #Define.Text74('Vierenzeventig')            // 74 - Seventy Four
        #Define.Text75('Vijfenzeventig')            // 75 - Seventy Five
        #Define.Text76('Zesenzeventig')             // 76 - Seventy Six
        #Define.Text77('Zevenenzeventig')           // 77 - Seventy Seven
        #Define.Text78('Achtenzeventig')            // 78 - Seventy Eight
        #Define.Text79('Negenenzeventig')           // 79 - Seventy Nine
        #Define.Text80('Tachtig')                   // 80 - Eighty
        #Define.Text81('Eenentachtig')              // 81 - Eighty One
        #Define.Text82('Tweeëntachtig')             // 82 - Eighty Two
        #Define.Text83('Drieëntachtig')             // 83 - Eighty Three
        #Define.Text84('Vierentachtig')             // 84 - Eighty Four
        #Define.Text85('Vijfentachtig')             // 85 - Eighty Five
        #Define.Text86('Zesentachtig')              // 86 - Eighty Six
        #Define.Text87('Zevenentachtig')            // 87 - Eighty Seven
        #Define.Text88('Achtentachtig')             // 88 - Eighty Eight
        #Define.Text89('Negenentachtig')            // 89 - Eighty Nine
        #Define.Text90('Negentig')                  // 90 - Ninety
        #Define.Text91('Eenennegentig')             // 91 - Ninety One
        #Define.Text92('Tweeënnegentig')            // 92 - Ninety Two
        #Define.Text93('Drieënnegentig')            // 93 - Ninety Three
        #Define.Text94('Vierennegentig')            // 94 - Ninety Four
        #Define.Text95('Vijfennegentig')            // 95 - Ninety Five
        #Define.Text96('Zesennegentig')             // 96 - Ninety Six
        #Define.Text97('Zevenennegentig')           // 97 - Ninety Seven
        #Define.Text98('Achtennegentig')            // 98 - Ninety Eight
        #Define.Text99('Negenennegentig')           // 99 - Ninety Nine
        #Define.Text100('Honderd')                  // 100 - One Hundred
        #Define.Text1000('Duizend')                 // 1000 - One Thousand
        #Define.Text1000000('Miljoen')              // 1000000 - Million
        #Define.Text1000000000('Miljard')           // 1000000000 - Billion
        #Define.Text1000000000000('Triljoen')       // 1000000000000 - Trillion
        #Define.TextAnd('En')                       // and
        #Define.TextHundredth('Hondersten')         // Hundredths
        #Define.TextOneHundredth('Honderste')       // One Hundredths
        #Define.Space(' ')

        /*
            Inline function builds the "hundreds" string.  In Dutch, this string is created the same way for
            all powers.  For instance, 123 (in Dutch) is the same rather used in the context of 123 or 123,000
            The function expects a number between 1 and 999.  Any other number will return a
            blank string.
            */
        str 50 buildHundredStr(int64 _number)
        {
            str 50 rtnStr;
            int64 numOfPower

            ;

            if (_number > 0 && _number < 1000)
            {
                numOfPower = _number div 100;

                if ((_number mod 100 == 0) && (numOfPower == 1))
                {
                    rtnStr = hundred;
                }
                else
                {
                    if  (numOfPower == 1)
                    {
                        rtnStr = hundred + lessThan100[_number mod 100];
                    }
                    else
                    {
                        if (_number mod 100 == 0)
                        {
                            rtnStr = lessThan100[numOfPower] + hundred;
                        }
                        else
                        {
                            if (numOfPower > 0)
                            {
                                rtnStr = lessThan100[numOfPower] + hundred + lessThan100[_number mod 100];
                            }
                            else
                            {
                                rtnStr = lessThan100[_number mod 100];
                            }
                        }
                    }
                }
            }
            return rtnStr;

        }

        /*
            Inline function determines how many of the given power exists in the given number.  The function
            then appends the appropriat Dutch string to returntxt.  Lastly, the function will remove the given
            power from the number (leaving only the portion of the number that is less than the given power).
            This value is then returned to the caller.
            */
        int64 checkPower(int64  _number, int64 _power)
        {

            int64   numOfPower = 0;

            //Determine how many of the given power exists in the given number
            if (_number >= _power)
            {
                numOfPower = _number div _power;
            }

            //Append the appropriate string for the given power to returntxt
            switch(_power)
            {
                case 1000000000000 :    //Trillions
                        if (numOfPower > 0)
                    {
                        returntxt = returntxt + buildHundredStr(numOfPower) + space + trillion + space;
                    }
                    break;
                case 1000000000 :       //Billions
                        if (numOfPower > 0)
                    {
                        returntxt = returntxt + buildHundredStr(numOfPower) + space + billion + space;
                    }
                    break;
                case 1000000 :          //Millions
                        if (numOfPower > 0)
                    {
                        returntxt = returntxt + buildHundredStr(numOfPower) + space + million + space;
                    }
                    break;
                case 1000 :             //Thousands
                        if (numOfPower > 0)
                    {
                        if ( numOfPower == 1)
                        {
                            returntxt = returntxt + thousand + space;
                        }
                        else
                        {
                            returntxt = returntxt +  buildHundredStr(numOfPower) + thousand + space;
                        }
                    }
                    break;
                case 1 :                //Hundreds (or Ones)
                        if (numOfPower > 0)
                    {
                        returntxt = returntxt + buildHundredStr(numOfPower);
                    }
                    else
                    {
                        if (numbOfDollars == 0)
                        {
                            returntxt = zero;
                        }
                    }
                    break;
            }

            //Remove the current power from the number and return
            _number = _number - (numOfPower * _power);
            return _number;

        }

        ;

        //If number is greater than 999,999,999,999,999 then no translation is done. Return empty string.
        if (decRound(_num, 2) > 999999999999999)
        {
            return returntxt;
        }

        //Initializing variables
        zero = #Text0;
        lessThan100[1] = #Text1;
        lessThan100[2] = #Text2;
        lessThan100[3] = #Text3;
        lessThan100[4] = #Text4;
        lessThan100[5] = #Text5;
        lessThan100[6] = #Text6;
        lessThan100[7] = #Text7;
        lessThan100[8] = #Text8;
        lessThan100[9] = #Text9;
        lessThan100[10] = #Text10;
        lessThan100[11] = #Text11;
        lessThan100[12] = #Text12;
        lessThan100[13] = #Text13;
        lessThan100[14] = #Text14;
        lessThan100[15] = #Text15;
        lessThan100[16] = #Text16;
        lessThan100[17] = #Text17;
        lessThan100[18] = #Text18;
        lessThan100[19] = #Text19;
        lessThan100[20] = #Text20;
        lessThan100[21] = #Text21;
        lessThan100[22] = #Text22;
        lessThan100[23] = #Text23;
        lessThan100[24] = #Text24;
        lessThan100[25] = #Text25;
        lessThan100[26] = #Text26;
        lessThan100[27] = #Text27;
        lessThan100[28] = #Text28;
        lessThan100[29] = #Text29;
        lessThan100[30] = #Text30;
        lessThan100[31] = #Text31;
        lessThan100[32] = #Text32;
        lessThan100[33] = #Text33;
        lessThan100[34] = #Text34;
        lessThan100[35] = #Text35;
        lessThan100[36] = #Text36;
        lessThan100[37] = #Text37;
        lessThan100[38] = #Text38;
        lessThan100[39] = #Text39;
        lessThan100[40] = #Text40;
        lessThan100[41] = #Text41;
        lessThan100[42] = #Text42;
        lessThan100[43] = #Text43;
        lessThan100[44] = #Text44;
        lessThan100[45] = #Text45;
        lessThan100[46] = #Text46;
        lessThan100[47] = #Text47;
        lessThan100[48] = #Text48;
        lessThan100[49] = #Text49;
        lessThan100[50] = #Text50;
        lessThan100[51] = #Text51;
        lessThan100[52] = #Text52;
        lessThan100[53] = #Text53;
        lessThan100[54] = #Text54;
        lessThan100[55] = #Text55;
        lessThan100[56] = #Text56;
        lessThan100[57] = #Text57;
        lessThan100[58] = #Text58;
        lessThan100[59] = #Text59;
        lessThan100[60] = #Text60;
        lessThan100[61] = #Text61;
        lessThan100[62] = #Text62;
        lessThan100[63] = #Text63;
        lessThan100[64] = #Text64;
        lessThan100[65] = #Text65;
        lessThan100[66] = #Text66;
        lessThan100[67] = #Text67;
        lessThan100[68] = #Text68;
        lessThan100[69] = #Text69;
        lessThan100[70] = #Text70;
        lessThan100[71] = #Text71;
        lessThan100[72] = #Text72;
        lessThan100[73] = #Text73;
        lessThan100[74] = #Text74;
        lessThan100[75] = #Text75;
        lessThan100[76] = #Text76;
        lessThan100[77] = #Text77;
        lessThan100[78] = #Text78;
        lessThan100[79] = #Text79;
        lessThan100[80] = #Text80;
        lessThan100[81] = #Text81;
        lessThan100[82] = #Text82;
        lessThan100[83] = #Text83;
        lessThan100[84] = #Text84;
        lessThan100[85] = #Text85;
        lessThan100[86] = #Text86;
        lessThan100[87] = #Text87;
        lessThan100[88] = #Text88;
        lessThan100[89] = #Text89;
        lessThan100[90] = #Text90;
        lessThan100[91] = #Text91;
        lessThan100[92] = #Text92;
        lessThan100[93] = #Text93;
        lessThan100[94] = #Text94;
        lessThan100[95] = #Text95;
        lessThan100[96] = #Text96;
        lessThan100[97] = #Text97;
        lessThan100[98] = #Text98;
        lessThan100[99] = #Text99;
        hundred = #Text100;
        thousand = #Text1000;
        million = #Text1000000;
        billion = #Text1000000000;
        trillion = #Text1000000000000;
        and = #TextAnd;
        zero = #Text0;
        hundredth = #TextHundredth;
        oneHundredth = #TextOneHundredth;
        space = #Space;

        temp = numbOfDollars;

        // Builds the string from the highest power digits on down, returntxt is updated in each call
        //  Note: These must be called in decreasing order of powers
        temp = checkPower(temp, 1000000000000);
        temp = checkPower(temp, 1000000000);
        temp = checkPower(temp, 1000000);
        temp = checkPower(temp, 1000);
        temp = checkPower(temp, 1);

        //Remove any trailing spaces
        returntxt = strRTrim(returntxt);

        //Build penny string
        switch (numOfPennies)
        {
            case 0:
                //Do nothing.  Decimals are not included when equal to 0/100.
                break;
            case 1:
                returntxt = returntxt + space + and + space + lessThan100[1] + space + oneHundredth;
                break;
            default:
                returntxt = returntxt + space + and + space + lessThan100[numOfPennies] + space + hundredth;
                break;
        }

        //Capitalize the first letter of the string and lower case the rest.
        if (strLen(returntxt) > 0)
        {
            returntxt = strUpr(subStr(returntxt, 1, 1)) + strLwr(subStr(returntxt,2,strLen(returntxt) -1));
        }

        //Add asteriks to string
        if (_enclose)
        {
            returntxt = '***' + returntxt;
        }

        return returntxt;
    }

    static int numOfDec(real r)
    {
        str s = num2str(frac(abs(r)),0,16,1,0);
        return strLen(strDel(s,strNFind(s,'0',strLen(s),-strLen(s))+1,strLen(s)))-2;
    }

    client static Object objectFromXMLNode(XmlNode n)
    {
        DictClass dc;
        Object retval;

        boolean hasCreateFromXMLMethod(DictClass _dc)
        {
            int i;
            for (i = 1; i <= _dc.staticMethodCnt(); i++)
            {
                if (_dc.staticMethod(i) == 'CreateFromXML')
                    return true;
            }
            return false;
        }

        //validate arguments before using them
        if (n == null)
            return null;

        dc = new DictClass(className2Id(n.nodeName()));
        if (dc)
        {
            if (hasCreateFromXMLMethod(dc))
            {
                // Call it

                // BP deviation documented
                retval = dc.callStatic('createFromXML', n);
            }
            else
            {
                // Use new
                retval = dc.makeObject();
                // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
                retval.loadFromXMl(n);
                // Syp Modifications - SP3 - ENd
            }
            // Syp Modifications - SP3 [V-ALEXA][HQ-921-681-FEAC] - BEGIn
            //retval.loadFromXMl(n);
            // Syp Modifications - SP3 - ENd
        }
        return retval;
    }

    /// <summary>
    /// Calculates the amount that must be paid every period to repay a loan.
    /// </summary>
    /// <param name="principal">The amount that was originally borrowed.</param>
    /// <param name="interest">The interest that is applied each period to the amount borrowed.</param>
    /// <param name="life">The number of periods over which the loan is repaid.</param>
    /// <returns>The amount that must be paid every period.</returns>
    static real payment(real principal, real interest, real life)
    {
        return pmt(principal, interest, life);
    }

    static real percent(real value, real base)
    {
        if (base)
            return value / base * 100;

        return 0;
    }

    static DataArea pickDataArea()
    {
        FormRun  formRun;
        Args    args;
        DataArea dataArea = null;
        anytype dataAreaStr;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::DataAreas));
        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
        
        dataAreaStr = formRun.selection();

        if (dataAreaStr)
        {
            select Id
                from dataArea
                where dataArea.Id == dataAreaStr;
        }

        return dataArea;
    }

    static int pickEnumValue(EnumId _enumId, boolean _omitZero = false)
    {
        FormRun      formRun;
        container   names;
        container   values;
        int         i,value = -1,valueIndex;
        str         name;
        #ResAppl
        DictEnum dictEnum = new DictEnum(_enumId);
        ;
        if (!dictEnum)
            return -1;


        for (i=1;i<=dictEnum.values();i++)
        {
            value = dictEnum.index2Value(i);
            if (!(_omitZero && (value == 0)))
            {
                names += dictEnum.index2Label(i);
                values += value;
            }
        }

        formRun = classfactory.createPicklist();
        formRun.init();
        formRun.choices(names, #ImageClass);
        formRun.caption(dictEnum.label());
        formRun.run();
        formRun.wait();
        name = formRun.choice();
        value = formRun.choiceInt();
        if (value>=0) // the picklist form returns -1 if a choice has not been made
        {
            valueIndex = -1;
            for (i=1;i<=conLen(names);i++)
            {
                if (name == conPeek(names,i))
                {
                    valueIndex = i;
                    break;
                }
            }
            if (valueIndex>=0)
                return conPeek(values,valueIndex);
        }

        return value;
    }

    /// <summary>
    /// Open a form to select from the list of fields on a given table. By default, open a dialog. If a lookupTargetControl is provided, open a lookup instead. 
    /// </summary>
    /// <param name="tableId">
    ///    The table containing the fields to select from.
    /// </param>
    /// <param name="lookupTargetControl">
    ///    Optional. The control hosting the lookup form.
    /// </param>
    /// <returns>
    ///    The extended fieldId of the field that is selected.
    /// </returns>
    static int pickField(TableId tableId, FormStringControl lookupTargetControl = null)
    {
        FormRun  formRun;
        Args    args;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::Fields));
        args.parm(int2str(tableId));
        formRun = classfactory.formRunClass(args);

        if(lookupTargetControl)
        {
            lookupTargetControl.performFormLookup(formRun);
        }
        else
        {
            formRun.init();
            formRun.run();
        }

        formRun.wait();

        if (formRun.selection())
            return formRun.selection();
        return 0;
    }

    static int pickIndex(IndexId indexId)
    {
        FormRun  formRun;
        Args    args;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::Indexes));
        args.parm(int2str(indexId));
        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
        if (formRun.selection())
            return formRun.selection();
        return 0;
    }

    private static int pickClassOrInterface(boolean _interfaceOnly, boolean _allowSystem)
    {
        formRun                     formRun;
        SysPickProgressParameters   parameters = new SysPickProgressParameters();

        parameters.PickListType     = SysPickListType::Classes;
        parameters.InterfaceOnly    = _interfaceOnly;
        parameters.AllowSystem      = _allowSystem;
        parameters.CaptionText      = _interfaceOnly? "@SYS62937" : "@SYS26387";

        formRun = classfactory.createProgressBarPicklist(parameters);
        formRun.init();        
        formRun.run();
        formRun.wait();
        if (parameters.Selection)
        {
            return dict.className2Id(parameters.Selection);
        }

        return 0;
    }

    static int pickInterface(boolean _showSystem = false)
    {
        return pickClassOrInterface(true, _showSystem);
    }

    static int pickClass(boolean _showSystem = false)
    {
        return pickClassOrInterface(false, _showSystem);
    }

    /*
        Map description:
        ID              TEXT
        map = new Map(Types::String,  Types::String)
        OR
        map = new Map(Types::Integer, Types::String)
    */
    static str pickList(Map _map, str _columnHeader = '', str _title = "@SYS5704", boolean _modal = false)
    {
        FormRun  formRun;
        Object  formRunObject;
        Args    args;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::Simple));
        args.parmObject(_map);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRunObject = formRun;
        formRunObject.setColumnHeader(_columnHeader);
        formRunObject.setCaption(_title);
        formRun.wait(_modal);

        if (formRunObject.selection())
        {
            return formRunObject.selection();
        }
        return '';
    }

    static int pickTable(boolean  _showMap     = false,               // Show maps?
        boolean  _showTemp    = false,               // Show temporary tables?
        boolean  _showSystem  = false,               // Show system tables?
        boolean  _showView    = false,               // Show tables which are views?
        boolean  _checkRights = false                // Only show tables which the user has View rights to?
        )
    {
        formRun                     formRun;
        SysPickProgressParameters   parameters = new SysPickProgressParameters();

        parameters.PickListType     = SysPickListType::Tables;
        parameters.AllowMap         = _showMap;
        parameters.AllowTemporary   = _showTemp;
        parameters.AllowView        = _showView;
        parameters.AllowSystem      = _showSystem;
        parameters.CheckRights      = _checkRights;
        parameters.CaptionText      = "@SYS9678";

        formRun = classfactory.createProgressBarPicklist(parameters);
        formRun.init();        
        formRun.run();
        formRun.wait();
        if (parameters.Selection)
        {
            return dict.tableName2Id(parameters.Selection);
        }

        return 0;
    }

    /*
        Map description:
        User id        User name
        map = new Map(Types::String, Types::String)
    */
    static UserId pickUser(Map _map = null, boolean _modal = false)
    {
        FormRun formRun;
        Object  formRunObject;
        Args    args;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::Users));
        args.parmObject(_map);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait(_modal);

        formRunObject = formRun;

        return formRunObject.selection();
    }

    static UserGroupId pickUserGroup(UserId userId = '')
    {
        FormRun  formRun;
        Args    args;

        args = new Args(formStr(SysPick));
        args.parmEnumType(enumNum(SysPickListType));
        args.parmEnum(enum2int(SysPickListType::UserGroups));
        args.parm(userId);
        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
        return formRun.selection();
    }

    /// <summary>
    /// Check if any field value of a record has changed
    /// </summary>
    /// <param name="_common">
    /// The record to check for change
    /// </param>
    /// <returns>
    /// true, if any field value has changed
    /// false otherwise
    /// </returns>
    /// <remarks>
    /// All fields, that have base types less than 7 will be checked;
    /// all other fields will NOT be checked.
    /// </remarks>
    public static boolean pmfTableHasChanged(Common _common)
    {
        DictTable   dictTable;
        DictField   dictField;
        Common      origBuf;
        int         i;

        #define.baseType(7)

        origBuf = _common.orig();
        dictTable = new DictTable(_common.TableId);

        for (i = 1; i <= dictTable.fieldCnt(); i++)
        {
            dictField = new DictField(_common.TableId,dictTable.fieldCnt2Id(i));
            if (dictField.baseType() < #baseType)
            {
                if (_common.(dictField.id()) != origBuf.(dictField.id()))
                {
                    return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Calculates the present value of an annuity where an amount is received over multiple periods and
    /// the interest rate is deducted for each period.
    /// </summary>
    /// <param name="amount">
    /// The amount paid during each period.
    /// </param>
    /// <param name="interest">
    /// The interest rate.
    /// </param>
    /// <param name="life">
    /// The number of times that the value specified by the amount parameter is paid.
    /// </param>
    /// <returns>
    /// The current value of an annuity.
    /// </returns>
    /// <remarks>
    /// This method calculates the present value of an annuity where the amount is received over multiple
    /// periods and the interest rate is deducted for each period.This method is a rename of the <c>pV</c>
    /// function.
    /// </remarks>
    static real presentValue(real amount, real interest, real life)
    {
        return pv(amount, interest, life);
    }

    static int primaryLanguageId (int languageId)
    {
        return languageId & 0x3ff;
    }

    client server static str queryName2Pname(QueryName queryName)
    {
        MenuFunction mf;
        Query query;

        try
        {
            mf = new MenuFunction(queryName, MenuItemType::Action);
        }
        catch(Exception::Internal)
        {
            mf = null;
        }

        if (mf)
        {
            return mf.label();
        }

        query = new Query(queryName);
        if (query)
        {
            return query.title();
        }
        return '';
    }

    static str queryNotValueCon_W(container _values)
    {
        return '!' + con2Str(_values, ',!');
    }

    /// <summary>
    ///    Returns a string that represents a range filter that can be used as value for
    ///    <c>QueryBuildRange</c>.
    /// </summary>
    /// <param name="_From">
    ///    The lower bound of the range; optional.
    /// </param>
    /// <param name="_To">
    ///    The upper bound of the range; optional.
    /// </param>
    /// <param name="treatOnlyNullAsUnbound">
    ///    A Boolean value that specifies whether to treat empty values as unbound; optional.
    /// </param>
    /// <returns>
    ///    A string representing a range filter that can be used as a value for the <c>QueryBuildRange</c>
    ///    method.
    /// </returns>
    /// <remarks>
    ///    This method generally returns the string in the format of '_from..._to'. If _from is null or empty
    ///    value and <c>treatOnlyNullAsUnbound</c> is set to false, the value is dropped from the string and
    ///    it becomes '..._to'. _from in this case represents an unbound value. This also applies for _to.
    ///    When both _from and _to are unbound values, the function returns an empty string and the range
    ///    filter will be dropped from the query when it is used as value for the <c>QueryBuildRange</c>
    ///    method.
    /// </remarks>
    static str queryRange(
        anytype _From,
        anytype _To,
        boolean treatOnlyNullAsUnbound = false)
    {
        return xSysQuery::range(_From,_To,treatOnlyNullAsUnbound);
    }

    static str queryRangeConcat(
        str     _queryRange,
        anytype _value)
    {
        if (_queryRange)
            return _queryRange + ',' + queryValue(_value);
        return queryValue(_value);
    }

    static str queryValue(anytype A)
    {
        return xSysQuery::value(a);
    }

    /// <summary>
    ///    Converts a value of <c>real</c> type into a <c>System.Double</c> type specified in <c>_value</c>
    ///    parameter.
    /// </summary>
    /// <param name="_value">
    ///    The value to be converted.
    /// </param>
    /// <returns>
    ///    A <c>System.Decimal</c> object.
    /// </returns>
    public static System.Double real2double(real _value)
    {
        System.Decimal decimalValue;
        System.Double doubleValue;

        decimalValue = CLRInterop::getObjectForAnyType( _value );
        doubleValue  = System.Decimal::ToDouble( decimalValue );

        return doubleValue;
    }

    client server static int real2int(real _realValue)
    {
        return any2int(_realValue);
        /*
            Note that this is equivalent of any2int(trunc(_realValue)) meaning that no rounding is performed

            Examples:
            info(strfmt("%1", real2int(123.456)));  // returns 123
            info(strfmt("%1", real2int(123.756)));  // returns 123
            info(strfmt("%1", real2int(-123.456))); // returns -123
            info(strfmt("%1", real2int(-123.756))); // returns -123
            */
    }

    static int real2UnsignedInt(real r)
    {
        real rmaxInt = maxInt();
        if (r<0)
            return 0;

        if (r>2*rmaxInt)
            return 0;

        if (r>rmaxInt)
            return any2int(-r+maxInt());

        return any2int(r);
    }

    /// <summary>
    /// Returns the max value allowed for real allowed by IL and the Interpretor.
    /// This value is the maximum able to be marshalled between X++ and Managed Code.
    /// Real can still be assigned values up to the original max 9.e127 but will throw an out of bounds exception in IL.
    /// </summary>
    /// <returns>Accepted max value for IL and the Interpreter</returns>
    static real realMax()
    {
        return 9.999999999999999e15;
    }

    /// <summary>
    /// Returns the min value allowed for real allowed by IL and the Interpretor.
    /// This value is the minimum able to be marshalled between X++ and Managed Code.
    /// Real can still be assigned values down to the original min -9.e127 but will throw an out of bounds exception in IL.
    /// </summary>
    /// <returns>Accepted min value for IL and the Interpreter</returns>
    static real realMin()
    {
        return -9.999999999999999e15;
    }

    static str record2DynaKey(Common rec)
    {
        TableId     tableId     = rec.TableId;
        DictTable   dictTable   = new DictTable(tableId);
        IndexId     indexId     = dictTable.indexUnique();
        DictIndex   dictIndex   = dictTable.indexObject(indexId);
        str buf;
        int indexCnt;
        int fieldsInIndex;
        FieldId fieldId;

        str any2strLocal(anytype t)
        {
            return t;
        }

        if (dictIndex.name() == 'RecId')                                            // RecId as index
                return '['+int2str(fieldNum(Common,RecId))+':'+int642str(rec.RecId)+']';
        else
        {
            fieldsInIndex = dictIndex.numberOfFields();
            for (indexCnt = 1; indexCnt <= fieldsInIndex; indexCnt++)
            {
                fieldId    = dictIndex.field(indexCnt);
                buf += '[' + int2str(fieldId) + ':';
                switch (typeOf(rec.(fieldId)))
                {
                    case Types::Date:
                        buf += date2str(rec.(fieldId),-1,-1,-1,-1,-1,-1, DateFlags::None);
                        break;
                    case Types::UtcDateTime:
                        buf += datetime2str(rec.(fieldId), DateFlags::None);
                        break;
                    default:
                        //buf += any2StrLocal(strReplace(rec.(fieldId),' ', '%20'));
                        buf += any2StrLocal(rec.(fieldId));
                }
                buf += ']';
            }
            if (dictIndex.allowDuplicates())
            {
                buf += '['+int2str(fieldNum(Common,RecId))+':'+int642str(rec.RecId)+']';
            }
        }
        return buf;
    }

    // Input is <Record table="name"> <Field:field1> value </Field:field1> ... </Record>
    static Common recordFromXMLNode(XmlNode n, Common c = null)
    {
        TableId table;
        FieldId field;
        DictTable dt;
        DictField df;
        XmlNode fieldNode;
        str fieldName;
        Struct content;
        XmlNode tableName;
        Types t;
        int extendedFieldIndex;

        //validate arguments before using them
        if (n == null)
            return null;
        // If we don't have an incoming buffer, one is created
        if (prmisDefault(c))
        {
            // Create a buffer of the correct type
            tableName = n.attributes().getNamedItem('name');

            // If node does not contain name attribute, try with table attribute.
            if (tableName == null)
            {
                tableName = n.attributes().getNamedItem('table');
            }

            // Check if table node can be accessed
            if (tableName != null)
            {
                table = tableName2id(tableName.nodeValue());
                dt = new DictTable(table);
                c = dt.makeRecord();
            }
        }
        else
        {
            table = c.TableId;
            dt = new DictTable(table);
        }

        fieldNode = n.firstChild();
        while (fieldNode)
        {
            fieldName = fieldNode.attributes().getNamedItem('name').text();
            field = dt.fieldName2Id(fieldName);

            if (extendedSerialization && !field)
            {
                //ignore in case of cursor from extended deserialization
                fieldNode = fieldNode.nextSibling();
                continue;
            }

            df = new DictField(table, field);

            t = df.baseType();
            if (t == Types::Enum) //Enums need to be treated as Integers. By defult, Enums are getting treated as a boolean and hence loosing its value.
                    t = Types::Integer;

            if (t == Types::Container)
            {
                content = valueFromXMLNode (t, fieldNode.firstChild());
            }
            else
            {
                content = valueFromXMLNode (t, fieldNode);
            }

            // If array substitute the fieldId of the array EDT with the fieldId of the elements
            if (df.arraySize() > 1)
            {
                extendedFieldIndex = str2int(fieldNode.attributes().getNamedItem('offset').text());
                c.(fieldId2Ext(field, extendedFieldIndex)) = content.value('value');
            }
            else
            {
                c.(field) = content.value('value');
            }


            fieldNode = fieldNode.nextSibling();
        }
        return c;
    }

    client server static str reportName2Pname(ReportName reportName)
    {
        MenuFunction mf;
        Report report;

        try
        {
            mf = new MenuFunction(reportName, MenuItemType::Output);
        }
        catch(Exception::Internal)
        {
            mf = null;
        }

        if (mf &&
            mf.label())
        {
            return mf.label();
        }

        report = new Report(reportName);
        if (report && report.design())
        {
            return report.design().caption();
        }

        return '';
    }

    static real roundDown(real value, real unit)
    {
        real roundedValue;

        roundedValue = round(value,unit);
        // Check for special case
        if (value== roundedValue)
            return value;
        // for numerical reasons we subtract the major part of the number before rounding
        return round(value - roundedValue - unit/2, unit)+roundedValue;
        //return round(value - unit/(2+unit/10),unit); // the new suggestion
    }

    static real roundDownDec(real value, int numDec)
    {
        real            unit = 1;
        while (numDec > 0)
        {
            unit        = unit/10;
            numDec      = numDec-1;
        }

        return roundDown(value,unit);
    }

    static real roundUp(real value, real unit)
    {
        real    roundedValue;

        roundedValue = round(value,unit);
        // Check for special case
        if (value== roundedValue)
            return value;
        // for numerical reasons we subtract the major part of the number before rounding
        return round(value - roundedValue + unit/2, unit)+roundedValue;
        //return round(value - unit/(2+unit/10),unit); // the new suggestion
    }

    static real roundUpDec(real value, int numDec)
    {
        real unit = 1;
        while (numDec > 0)
        {
            unit        = unit/10;
            numDec      = numDec-1;
        }

        return roundUp(value,unit);
    }

    static real roundZero(real value, real unit)
    {
        if (value >= 0)
            return roundDown(value, unit);

        return roundUp(  value, unit);

    }

    static real roundZeroDec(real value, int numDec)
    {
        real unit = 1;
        while (numDec > 0)
        {
            unit       = unit/10;
            numDec     = numDec-1;
        }

        if (value >= 0)
            return roundDown(value,unit);

        return roundUp(value,unit);
    }

    /// <summary>
    /// Runs the specified method and makes sure it is executed under the Xpp IL.
    /// </summary>
    /// <param name="_className">
    /// The name of the class that contains the method.
    /// </param>
    /// <param name="_methodName">
    /// The static method to call.
    /// </param>
    /// <param name="_params">
    /// The container of parameters to pass to the method.
    /// </param>
    /// <param name="_ignoreTtsLevel">
    /// Forces to IL even if the tts level is larger than 0.
    /// </param>
    /// <returns>
    /// The result of the method call as a container.
    /// </returns>
    /// <remarks>
    /// This demands the <c>XppILExecutePermission</c> class and asserts both the <c>RunAsPermission</c>
    /// and <c>ExecutePermission</c>. The call will transition to Xpp IL using <c>runAs</c> if running
    /// interpreted. If running as Xpp IL, the method is just called directly.As there may be some
    /// overhead, this method should only be used on computationally expensive methods.This method will not
    /// transition to IL if the current tts level is larger than 0 (unless forced) because transaction
    /// scope does not flow across IL boundaries.IL is also referred to as CIL, for the common intermediate
    /// language of the .NET Framework.
    /// </remarks>
    [SysObsoleteAttribute("The runClassMethodIL causes a reflection call, and should not be used in application code. Call the designated static method directly, passing the container argument.", true, 13\02\2014)]
    public static container runClassMethodIL(ClassName _className, MethodName _methodName, container _params, boolean _ignoreTtsLevel = false)
    {
        return SysDictClass::invokeStaticMethodIL(_className, _methodName, _params, _ignoreTtsLevel);
    }

    /// <summary>
    /// Runs the specified method and makes sure it is executed under Xpp IL.
    /// </summary>
    /// <param name="_tableName">
    /// The name of the table that contains the method.
    /// </param>
    /// <param name="_methodName">
    /// The static method to called.
    /// </param>
    /// <param name="_params">
    /// The container of parameters to pass to the method.
    /// </param>
    /// <param name="_ignoreTtsLevel">
    /// Forces to IL even if the tts level is larger than 0.
    /// </param>
    /// <returns>
    /// The result of the method call as a container.
    /// </returns>
    /// <remarks>
    /// This demands the <c>XppILExecutePermission</c> class and asserts both the <c>RunAsPermission</c>
    /// and <c>ExecutePermission</c>. The call will transition to Xpp IL using <c>runAs</c> if running
    /// interpreted. If running as Xpp IL, the method is just called directly. As there may be some
    /// overhead, this method should only be used on computationally expensive methods. This method will
    /// not transition to IL if the current tts level is larger than 0 (unless forced) because transaction
    /// scope does not flow across IL boundaries.IL is also referred to as CIL, for the common intermediate
    /// language of the .NET Framework.
    /// </remarks>
    [SysObsoleteAttribute("The runTableMethodIL causes a reflection call, and should not be used in application code. Call the designated static method directly, passing the container argument.", true, 13\02\2014)]
    public static server container runTableMethodIL(TableName _tableName, MethodName _methodName, container _params, boolean _ignoreTtsLevel = false)
    {
        return SysDictTable::invokeStaticMethodIL(_tableName, _methodName, _params, _ignoreTtsLevel);
    }

    /* MAN
            Modifies the value of a property in the supplied property set.
            If the property does not exist the original property set is returned.
    */
    #Properties
    static str setProperty(str properties, str propertyname, str value)
    {
        str s = properties;
        int slen=strLen(s);
        int propertyPos;
        int arrayPos;
        int propertyLen;

        propertyPos = findPropertyPos(properties, propertyname);
        if (propertyname == #PropertyExtendedDataType)
        {
            // Extended property may be written on multiple lines
            arrayPos = strScan(s, 'ARRAY', propertyPos, slen);
            if (arrayPos)
            {
                // ARRAY was found so move to the correct place
                propertyPos = arrayPos;
                propertyPos = strScan(s, '\n', propertyPos,slen);
                if (!propertyPos)
                    return s;
                propertyPos++;
            }
        }
        propertyLen = strScan(s, '\n', propertyPos, slen);
        if (!propertyPos)
            return s;

        propertyPos = strScan(s, '#', propertyPos,   slen)+1;

        if (!propertyLen)
            propertyLen = slen;

        s = strDel(s, propertyPos, propertyLen-propertyPos+1);
        s = strIns(s, value+'\n', propertyPos);
        return s;
    }

    /// <summary>
    /// Sets whether the record template prompt should be suppressed.
    /// </summary>
    /// <param name="_isRecordTemplatePromptGloballySuppressed">
    /// true if the prompt should be suppressed; otherwise, false.
    /// </param>
    public static void setRecordTemplatePromptGlobalSuppression(boolean _isRecordTemplatePromptGloballySuppressed)
    {
        if (_isRecordTemplatePromptGloballySuppressed)
        {
            infolog.globalCache().set(classStr(Global), staticMethodStr(Global, setRecordTemplatePromptGlobalSuppression), true);
        }
        else
        {
            infolog.globalCache().remove(classStr(Global), staticMethodStr(Global, setRecordTemplatePromptGlobalSuppression));
        }
    }

    /// <summary>
    ///    Retrieves an exception message if a user does not have the necessary access level.
    /// </summary>
    /// <param name="_common">
    ///    A table buffer that indicates the fields to which the user has access; optional.
    /// </param>
    /// <param name="_fieldList">
    ///    The list of fields to display in the message; optional.
    /// </param>
    /// <param name="_neededAccessLevel">
    ///    The access level that is needed; optional.
    /// </param>
    /// <param name="_helpUrl">
    ///    The help link for the message to display; optional.
    /// </param>
    /// <param name="_sysInfoAction">
    ///    The layout type of the Infolog window; optional.
    /// </param>
    /// <returns>
    ///    An exception message.
    /// </returns>
    /// <remarks>
    ///    This method determines whether a buffer and list of fields are specified.If the field list is
    ///    specified than it will be displayed to the user; otherwise, the list will be generated
    ///    automatically if the table buffer is specified.This method checks for access for all fields in the
    ///    table buffer and stores the fields that cannot be accessed in a list.If both the buffer and filter
    ///    are not specified, a default error message is displayed.If the access level is not specified and a
    ///    table buffer has not been specified, the needed access level is set to view.
    /// </remarks>
    public client server static Exception showFieldAccessException(
        Common          _common = null,
        TreeNodeTxt     _fieldList = '',
        AccessRight     _neededAccessLevel = AccessRight::View,
        URL             _helpUrl = '',
        SysInfoAction   _sysInfoAction = null)
    {
        SysDictTable    dictTable;
        SysDictField    sysDictField;
        TreeNodeTxt     localFieldList = _fieldList;
        int             i;


        if (_common != null
            && localFieldList == '')
        {
            dictTable = new SysDictTable(_common.TableId);
            if (dictTable)
            {
                for (i = 1; i <= dictTable.fieldCnt(); i++)
                {
                    sysDictField = new SysDictField(_common.TableId, dictTable.fieldCnt2Id(i));

                    if (_common.fieldAccessRight(sysDictField.name()) < _neededAccessLevel)
                    {
                        if (localFieldList == '')
                        {
                            localFieldList = fieldId2name(_common.TableId, sysDictField.id());
                        }
                        else
                        {
                            localFieldList = localFieldList + ', ' + fieldId2name(_common.TableId, sysDictField.id());
                        }
                    }
                }
            }
        }

        if (localFieldList == '')
        {
            return error("@SYS126562", _helpUrl, _sysInfoAction);
        }
        else
        {
            return error(strFmt("@SYS121974", tableId2name(_common.TableId), localFieldList), _helpUrl, _sysInfoAction);
        }
    }

    static real sign(real num)
    {
        return num >= 0 ? 1 : -1;
    }

    static real sqrt(real a)
    {
        return power(a, 0.5);
    }

    [SysObsoleteAttribute('startLengthyOperation is deprecated and no longer needed. You can safely remove calls to this method', true, 27\11\2014)]
    static void startLengthyOperation()
    {
    }

    /// <summary>
    /// Returns the given string with the first letter as uppercase, and the rest lowercase.
    /// </summary>
    /// <param name="_str">
    /// The String value to convert.
    /// </param>
    /// <returns>
    /// The converted string with the first letter as uppercase, and the rest lowercase.
    /// </returns>
    static str str2Capital(str _str)
    {
        return strUpr(subStr(_str, 1, 1)) + strLwr(subStr(_str, 2, 999999));
    }

    static str str2CapitalWord(str _str)
    {
        int n;

        _str = str2Capital(_str);
        n    = strScan(_str, ' ', 1, strLen(_str));
        while (n)
        {
            n++;
            _str = strPoke(_str, strUpr(subStr(_str, n, 1)), n);
            n    = strScan(_str, ' ', n, strLen(_str));
        }
        return _str;
    }

    /// <summary>
    /// Splits the given String by the specified separator and returns the contents in a container.
    /// </summary>
    /// <param name="_value">
    /// The String value to be split.
    /// </param>
    /// <param name="_sep">
    /// The separator.
    /// </param>
    /// <param name="_convertNumericToInt64">
    /// A Boolean value that indicates whether to convert the value to an <c>int64</c> value; optional.
    /// </param>
    /// <returns>
    /// A container, which has the String split by the specified separator.
    /// </returns>
    /// <remarks>
    /// In the <paramref name="_convertNumericToInt64" /> parameter, a value of true indicates the returned
    /// contents will be converted to an <c>int64</c> value if they only have numeric characters.A value of
    /// false indicates that the returned values will not be converted to an <c>int64</c> value and String
    /// values will always be returned. The default value of the <paramref name="_convertNumericToInt64" />
    /// parameter is true.
    /// </remarks>
    static container str2con(str _value, str 10 _sep = ',', boolean _convertNumericToInt64 = true)
    {
        int         length = strLen(_value);
        int         separatorLength = strLen(_sep);
        int         i = 1;
        int         j = strScan(_value, _sep, 1, length);
        container   ret;
        void add2Ret(str _current)
        {
            if (_convertNumericToInt64 && str2IntOk(_current))
            {
                ret += str2int64(_current);
            }
            else
            {
                ret += _current;
            }
        }

        while (j)
        {
            add2Ret(subStr(_value, i, j-i));
            i = j + separatorLength;
            j = strScan(_value, _sep, i, length);
        }
        add2Ret(subStr(_value, i, length-i+1));
        return ret;
    }

    #define.Comma(",")
    static container str2con_RU(str _string, str _separator = #Comma, boolean _ignoreNearSeparator = false)
    {
        container con = conNull();
        int       pos, oldPos = 1;
        str       tmpStr;

        do
        {
            pos    =  strScan(_string, _separator, pos ? pos + strLen(_separator) : 1, strLen(_string));
            tmpStr =  subStr(_string, oldPos, pos ? pos - oldPos : strLen(_string) + 1 - oldPos);
            if (tmpStr || ! _ignoreNearSeparator)
            {
                con += tmpStr;
            }
            oldPos =  pos + strLen(_separator);
        }
        while (pos);

        return con;
    }

    static CryptoBlob str2cryptoblob(str _data)
    {
        Binary b = new Binary((strLen(_data) + 1)*2);

        if (_data)
        {
            b.wString(0,_data);

            return binary2cryptoblob(b,(strLen(_data) +1)*2);
        }
        else
            return conNull();

    }

    static date  str2DateDMY(str 10 _str)
    {
        return str2Date(_str, 123);
    }

    [SysObsolete('This function generates poor hash keys that are likely to have collisions. Use strHash for new scenarios.', false, 26\04\2021)]
    static int str2HashKey(str _str)
    {
        int i, hash;
        int len = strLen(_str);

        for (i=1; i<=len; i++)
        {
            hash = (hash << 5) + hash + char2num(_str, i);
        }
        return hash;
    }

    /// <summary>
    /// Provide a hash value for the string.
    /// </summary>
    /// <param name='_str'>The string to hash.</param>
    /// <returns>The hash code for the argument string.</returns>
    /// <remarks>
    /// This method uses the .NET hashing function unmodified.
    /// </remarks>
    public static int strHash(str _str)
    {
        System.String systemString = _str;
        return systemString.GetHashCode();
    }

    static boolean str2IntOk(str 100 _str)
    {
        boolean retval;
        InteropPermission permission;
        System.Text.RegularExpressions.Regex re;

        permission = new InteropPermission(InteropKind::ClrInterop);
        permission.assert();

        // BP deviation documented
        re = new System.Text.RegularExpressions.Regex('^\\s*[+\\-]?\\s*[0-9]+\\s*$');

        //return ClrInterop::getAnyTypeForObject(re.IsMatch(_str));

        // BP deviation documented
        retval = CLRInterop::getAnyTypeForObject(re.IsMatch(_str));

        return retval;
    }

    static real str2num_RU(TempStr _text)
    {
        return str2num(str2numPrep(_text));
    }

    static boolean str2numOK(TempStr _tempStr)
    {
        boolean retval;
        InteropPermission permission;
        System.Text.RegularExpressions.Regex re;

        permission = new InteropPermission(InteropKind::ClrInterop);
        permission.assert();

        // BP deviation documented
        re = new System.Text.RegularExpressions.Regex(
                '^\\s*[+\\-]?\\s*[0-9]+(\\.[0-9]+)?([+\\-]?[Ee][+\\-]?[1-9][0-9]*)?\\s*$');

        //return ClrInterop::getAnyTypeForObject(re.IsMatch(_tempStr));
        // BP deviation documented
        retval = CLRInterop::getAnyTypeForObject(re.IsMatch(_tempStr));
        return retval;
    }

    static boolean str2numOK_RU(TempStr _tempStr)
    {
        return str2numOK(str2numPrep(_tempStr));
    }

    /// <summary>
    /// Performs string pre-processing to soften requirements for the input string to be convertable to numeral.
    /// </summary>
    /// <param name="_text">
    /// Text representation of a number.
    /// </param>
    /// <returns>
    /// String that has first occurence of comma (if any) replaced with dot.
    /// </returns>
    /// <remarks>
    /// Assumption is that valuable result should be produced if <paramref name="_text"/> represents a number with comma or dot as a decimal separator.
    /// </remarks>
    private static TempStr str2numPrep(TempStr _text)
    {
        #define.comma(',')
        #define.dot  ('.')

        TempStr ret = _text;
        int     commaPos = strFind(ret, #comma, 1, maxInt());

        if (commaPos)
        {
            ret = strPoke(ret, #dot, commaPos);
        }

        return ret;
    }

    static RecId str2recId(str _recIdStr)
    {
        return str2int64(_recIdStr);
    }

    #define.Comma(",")
    static public Set str2set_W(str _string, str _separator = #Comma)
    {
        Set ret = new Set(Types::String);
        int pos, oldPos = 1;

        do
        {
            pos    =  strScan(_string,
                              _separator,
                              pos ? pos + strLen(_separator) : 1,
                              strLen(_string));

            ret.add(subStr(_string,
                           oldPos,
                           pos ? pos - oldPos : strLen(_string) + 1 - oldPos));

            oldPos =  pos + strLen(_separator);
        }
        while (pos);

        return ret;
    }

    /// <summary>
    /// Retrieves the constant depreciation amount for the specified asset for each depreciation period.
    /// </summary>
    /// <param name="price">
    /// The purchase price of the asset.
    /// </param>
    /// <param name="scrap">
    /// The scrap value of the asset.
    /// </param>
    /// <param name="life">
    /// The number of periods in the expected life of the asset.
    /// </param>
    /// <returns>
    /// The depreciation amount.
    /// </returns>
    /// <remarks>
    /// This method is a rename of the <c>sln</c> method.
    /// </remarks>
    static real straightLineDepreciation(real price, real scrap, real life)
    {
        return sln(price, scrap, life);
    }

    static public boolean strContains(str _text, str _potentialContains)
    {
        if (strScan(_text, _potentialContains, 1, maxInt()))
            return true;
        return false;
    }

    static boolean strEndsWith(str _string, str _potentialEnd)
    {
        if (subStr(_string, strLen(_string)+1-strLen(_potentialEnd), strLen(_potentialEnd)) == _potentialEnd)
            return true;
        return false;
    }

    /// <summary>
    /// Formats the string using the specified language ID.
    /// </summary>
    /// <param name="_languageId">
    /// The languege ID to be used as a culture for formatting the string.
    /// </param>
    /// <param name="_format">
    /// The format string. Contains the placeholders for the values to be used in the formatted string. The placeholders are in .NET format.
    /// </param>
    /// <param name="_value0">
    /// The value for the first placeholder in the format string.
    /// </param>
    /// <param name="_value1">
    /// The value for the second placeholder in the format string.
    /// </param>
    /// <param name="_value2">
    /// The value for the third placeholder in the format string.
    /// </param>
    /// <returns>
    /// The formatted string.
    /// </returns>
    /// <remarks>
    /// The format string should follow the .NET syntax.
    /// </remarks>
    public static str strFmtByLanguage(LanguageId _languageId, str _format, anytype _value0, anytype _value1 = 0, anytype _value2 = 0)
    {
        System.Globalization.CultureInfo culture;
        System.Object [] obj;
        str res;
        int valuesCount = 1;
        System.Exception e;

        if (!prmisDefault(_value1))
        {
            valuesCount++;
        }

        if (!prmisDefault(_value2))
        {
            valuesCount++;
        }

        obj = new System.Object[valuesCount]();

        obj.SetValue(_value0, 0);

        if (!prmisDefault(_value1))
        {
            obj.SetValue(_value1, 1);
        }

        if (!prmisDefault(_value2))
        {
            obj.SetValue(_value2, 2);
        }

        try
        {
            culture = new System.Globalization.CultureInfo(_languageId);
        }
        catch
        {
            culture = new System.Globalization.CultureInfo('en-US');
        }

        if ((culture.CultureTypes & System.Globalization.CultureTypes::UserCustomCulture) != 0)
        {
            culture = new System.Globalization.CultureInfo('en-US');
        }

        try
        {
            res = System.String::Format(culture, _format, obj);
        }
        catch(Exception::CLRError)
        {
            e = CLRInterop::getLastException();
            while( e )
            {
                error( e.get_Message() );
                e = e.get_InnerException();
            }
            throw Exception::Error;
        }

        return res;
    }

    /// <summary>
    /// Replaces each occurrence of the characters ‘<c>\n</c>’ with one newline hexadecimal character 0x0A.
    /// </summary>
    /// <param name="_str">
    /// The original String that might contain occurrences of ‘<c>\n</c>’.
    /// </param>
    /// <returns>
    /// A String that contains newline hexadecimal characters instead of the ‘<c>\n</c>’ character pairs.
    /// </returns>
    /// <remarks>
    /// This method can be used to improve the display in message boxes of Strings that contain ‘<c>\n</c>’
    /// substrings.
    /// </remarks>
    static str strFmtLB(str _str)
    {
        int i = strScan(_str, '\\n', 1, strLen(_str));

        while (i)
        {
            _str = strDel(_str, i, 2);
            _str = strIns(_str, '\n', i);
            i    = strScan(_str, '\\n', i, strLen(_str));
        }
        return _str;
    }

    //BP Deviation Documented
    static str stringFromGuid(guid _value)
    {
        return guid2str(_value);
    }

    static str strLFix(str _str, int _length, char _char = ' ')
    {
        return subStr(_str, 1, _length) + strRep(_char, _length - strLen(_str));
    }

    /// <summary>
    /// Concatenates a string list elements into a string.
    /// </summary>
    /// <param name="_list">
    /// A list of string.
    /// </param>
    /// <param name="_delimiter">
    /// A delimiter.
    /// </param>
    /// <returns>
    /// A string created from a list.
    /// </returns>
    public static str strList2str(List _list, str _delimiter = ', ')
    {
        ListIterator    listIterator = new ListIterator(_list);
        str             result;

        while (listIterator.more())
        {
            result += listIterator.value();

            listIterator.next();

            if (listIterator.more())
            {
                result += _delimiter;
            }
        }

        return result;
    }

    static str strLRTrim(str _str)
    {
        return strLTrim(strRTrim(_str));
    }

    static str 1000 strMax(ExtendedDataTypeName _name = '')
    {
        DictType    dt;
        int         len;

        if (! prmisDefault(_name))
        {
            dt  = new DictType(extendedTypeName2Id(_name));
            if (dt == null)
                len = 1000;
            else
                len = dt.stringLen();
        }
        else
        {
            len = 1000;
        }

        return strRep(charMax(), len);
    }

    static TempStr strMin()
    {
        return '';
    }

    static str strRemoveCr(str s)
    {
        return strReplace(s, '\n', ' ');
    }

    static str strReplace(str _str, str _fromStr, str _toStr)
    {
        if(_fromStr==null || _fromStr == '' || _fromStr==_toStr)
        {
            return _str;
        }

        var matchPattern = System.Text.RegularExpressions.Regex::Escape(_fromStr);
        var matchOptions = System.Text.RegularExpressions.RegexOptions::IgnoreCase;

        return System.Text.RegularExpressions.Regex::Replace(_str, matchPattern, _toStr, matchOptions);
    }

    static str strReplaceChars(str _str, char _char, int _cnt = 1)
    {
        return strReplace(_str, _char, strRep(_char, _cnt));
    }

    /*
            Returns the input string reversed, so the first character becomes the last etc.
            Examples:
            A                               A
            Axapta                          atpaxA
            strReverse                      esreveRrts
            palindrom                       mordnilap
            RusserDressur                   russerDressuR
    */
    static str strReverse(str _str)
    {
        str ret;
        int i;

        for (i = strLen(_str); i > 0; i--)
        {
            ret += subStr(_str, i, 1);
        }
        return ret;
    }

    static str strRFix(str _str, int _length, char _char = ' ')
    {
        return strRep(_char, _length - strLen(_str)) + subStr(_str, 1, _length);
    }

    /// <summary>
    ///    Splits a string into a list of substrings delimited by elements in the specified delimiter string.
    /// </summary>
    /// <param name="_stringToSplit">
    ///    The string to split into a list.
    /// </param>
    /// <param name="_delimiters">
    ///    A string of delimiter characters.
    /// </param>
    /// <returns>
    ///    A list of substrings from the <paramref name="_stringToSplit" /> parameter.
    /// </returns>
    /// <remarks>
    ///    Each character in the <paramref name="_delimiter" /> string is used to split the <paramref
    ///    name="_stringToSplit" /> parameter.
    /// </remarks>
    static List strSplit(str _stringToSplit, str _delimiters)
    {
        List list = new List(Types::String);
        int oldPos = 1;
        int pos;
        int strLength = strLen(_stringToSplit);

        do
        {
            pos = strFind(_stringToSplit, _delimiters, oldPos, strLength);
            if (!pos)
                pos = strLength+1;

            list.addEnd(subStr(_stringToSplit, oldPos, pos-oldPos));
            oldPos = pos+1;
        }
        while (pos <= strLength);

        return list;
    }

    static public boolean strStartsWith(str _string, str _potentialStart)
    {
        if (subStr(_string, 1, strLen(_potentialStart)) == _potentialStart)
            return true;
        return false;
    }

    static int sumDigits(int number)
    {
        int             charNum;
        int             charMax;
        int             sumDigits;
        str 20          chars;

        chars       = int2str(number);
        charMax     = strLen(chars);

        charNum = 0;
        while (charNum < charMax)
        {
            charNum   += 1;
            sumDigits += any2Int(str2num(subStr(chars,charNum,1)));
        }

        return sumDigits;
    }

    static int symbol2Enum(EnumId _id, str _symbol)
    {
        DictEnum de = new DictEnum(_id);

        return de.symbol2Value(_symbol);
    }

    client server static boolean tableHasInstanceMethod(DictTable      dt,
                                                        IdentifierName methodName
                                                       )
    {
        DictMethod dictMethod;

        //validate arguments before using them
        if (dt == null)
            return false;
        dictMethod = new DictMethod(UtilElementType::TableInstanceMethod,dt.id(),methodName);
        return dictMethod && dictMethod.compiledOk();
    }

    /// <summary>
    ///     Gets the base type of the column specified.
    /// </summary>
    /// <param name = "_record">A table buffer.</param>
    /// <param name = "_fieldId">An ID of a field in the table.</param>
    /// <returns>The base type of the table column.</returns>
    public static Types tableColumnType(Common _record, int _fieldId)
    {
        SysDictField sysDictField  = new SysDictField(_record.TableId, _fieldId);
        Types        columnType    = sysDictField.baseType();
        return columnType;
    }

    client server static boolean tableHasMethod(
        DictTable      dt,
        IdentifierName methodName
        )
    {
        return SysDictTable::hasMethod(dt,methodName);
    }

    client server static boolean tableHasStaticMethod(DictTable      dt,
                                                      IdentifierName methodName
                                                     )
    {
        DictMethod dictMethod;

        //validate argumenrs before using them
        if (dt == null)
            return false;
        dictMethod = new DictMethod(UtilElementType::TableStaticMethod,dt.id(),methodName);

        return dictMethod && dictMethod.compiledOk();
    }

    static TableName tableId2Name(TableId _tableId)
    {
        DictTable dictTable = new DictTable(_tableId);
        if (dictTable)
            return dictTable.name();
        return '';
    }

    static int tableName2Id(str _tableName)
    {
        return dict.tableName2Id(_tableName);
    }

    static TempStr time2StrHM(int timE)
    {
        return num2str( timE div 3600       ,2,0,0,0)+':'+
               num2Str0(timE mod 3600 div 60,2,0,0,0);
    }

    static TempStr time2StrHMLeadingZero(int timE)
    {
        str hourStr;

        hourStr = num2str( timE div 3600       ,2,0,0,0);
        hourStr = strReplace(hourStr,' ','0');
        return hourStr+':'+
               num2Str0(timE mod 3600 div 60,2,0,0,0);
    }

    static TempStr time2StrHMS(int time)
    {
        return num2str( time div 3600       ,2,0,0,0)+':'+
               num2Str0(time mod 3600 div 60,2,0,0,0)+':'+
               num2Str0(time mod 3600 mod 60,2,0,0,0);
    }

    /// <summary>
    /// Returns a time consumed string in the formation X hours X minutes X seconds. If X is 0 will not include the value + text.
    /// Handles up to a 24 hour time difference not dependent on start/end time. If time consumed > 24 hours will only report time over 24 hour intervals.
    /// </summary>
    /// <param name="_startTime">Time process started</param>
    /// <param name="_endTime">Time process ended</param>
    /// <returns> (string) x hour/s x minute/s x seconds</returns>
    public static str timeConsumed(int _startTime, int _endTime)
    {
        int seconds, minutes, hours, totalTime;
        str timeStr = "";

        if (_startTime > _endTime)
        {
            totalTime = _endTime + (str2time('23:59:59') - _startTime);
        }
        else
        {
            totalTime = _endTime - _startTime;
        }

        seconds = totalTime mod 60;
        minutes = totalTime mod 3600 div 60;
        hours = totalTime div 3600;

        if (hours > 0)
            if (hours == 1)
                timestr = timeStr + strFmt("@SYS90502", hours);
        else
                timestr = timeStr + strFmt("@SYS54202", hours);

        if (minutes > 0)
            if (minutes == 1)
                timestr = timeStr + ' ' + strFmt("@SYS90503", minutes);
        else
                timeStr = timeStr + ' ' + strFmt("@SYS54205", minutes);

        if (seconds > 0)
            timestr = timeStr + ' ' + strFmt("@SYS54206", seconds);

        return strLRTrim(timeStr);
    }

    static client server int timeMax()
    {
        return DateTimeUtil::time(DateTimeUtil::maxValue());
    }

    /*
            Returns a valid Extended Data Type Id, given the argument in the form the system function typeId returns
            */
    static ExtendedTypeId typeId2ExtendedTypeId(int _extendedType)
    {
        if ((_extendedType & 0xffff) != Types::UserType)
            throw error(strFmt("@SYS26445",funcName()));

        return _extendedType >> 16 & 0xffff;
    }

    /*
            Returns the base type of a type, given the argument in the form the system function typeId returns
            */
    static Types typeId2Type(int _id)
    {
        return extendedTypeId2Type(typeId2ExtendedTypeId(_id));
    }

    /// <summary>
    ///    Retrieves the base type of a type.
    /// </summary>
    /// <param name="_typeName">
    ///    The name of an X++ type.
    /// </param>
    /// <returns>
    ///    The base type of a type.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The type name that was passed into the method is not a recognized X++ type.
    /// </exception>
    static Types typeName2Type(IdentifierName _typeName)
    {
        int id = extendedTypeName2Id(_typeName);

        if (id)
            return extendedTypeId2Type(id);

        if (enumName2Id(_typeName))
            return Types::Enum;

        if (className2Id(_typeName))
            return Types::Class;

        if (tableName2id(_typeName))
            return Types::Record;

        throw error(Error::wrongUseOfFunction(funcName()));
    }

    public static real units2mm(real  _measurement,
                                Units _units)
    {
        real    convertedMeasurement;

        if (_measurement)
        {
            switch (_units)
            {
                case Units::mm :
                    convertedMeasurement = _measurement;
                    break;

                case Units::cm :
                    convertedMeasurement = _measurement * 10.0;
                    break;

                case Units::pt :
                    convertedMeasurement = _measurement * 25.3995 / 72;
                    break;

                case Units::char :
                    convertedMeasurement = _measurement * 4.2;
                    break;

                case Units::Inch :
                    convertedMeasurement = _measurement * 25.3995;
                    break;
            }
        }
        else
        {
            convertedMeasurement = _measurement;
        }
        return convertedMeasurement;
    }

    static real unsignedInt2Real(int i)
    {
        real rmaxInt = maxInt();
        real rminInt = minInt();
        real r = i;

        if (i<0)
            return 1+rmaxInt+r-rminInt;
        return i;
    }

    /// <summary>
    /// Converts an X++ <c>utcdatetime</c> value to a .NET <c>System.DateTime</c> object.
    /// </summary>
    /// <param name="_utcDateTime">
    /// The X++ <c>utcdatetime</c> to convert.
    /// </param>
    /// <returns>
    /// A .NET <c>System.DateTime</c> object.
    /// </returns>
    static client server anytype utcDateTime2SystemDateTime(utcdatetime _utcDateTime)
    {
        // BP Deviation documented
        return CLRInterop::getObjectForAnyType(_utcDateTime);
    }

    static utcdatetime utcDateTimeNull()
    {
        return 1900-01-01T00:00:00;
    }

    static Struct valueFromXMLNode (Types t, XmlNode n)
    {
        #define.value('value')
        Struct retval;
        boolean enum; // Any enumeration type will do...

        //validate arguments befor using them
        if (n == null)
            return null;

        retval = new Struct(t, #value);
        switch(t)
        {
            case Types::Int64 :
                retval.value(#value, str2int64(getXmlNodeValue(n)));
                break;

            case Types::Integer :
                retval.value(#value, str2int(getXmlNodeValue(n)));
                break;

            case Types::Class :
                retval.value(#value, objectFromXMLNode(n));
                break;

            case Types::Container :
                retval.value(#value, containerFromXMLNode(n));
                break;

            case Types::Guid :
                retval.value(#value, str2guid(getXmlNodeValue(n)));
                break;

            case Types::Date :
                retval.value(#value, str2Date(getXmlNodeValue(n), 321));
                break;

            case Types::UtcDateTime:
                retval.value(#value, str2datetime(getXmlNodeValue(n), DateFlags::None));
                break;

            case Types::Enum :
                enum = str2int(getXmlNodeValue(n));
                retval.value(#value, enum);
                break;

            case Types::Real :
                retval.value(#value, str2num(getXmlNodeValue(n)));
                break;

            case Types::Record :
                retval.value(#value, recordFromXMLNode(n));
                break;

            case Types::BLOB :
                // <element type="blob"> 0123192648172.... </element>
                retval.value(#value, BinData::stringToData(getXmlNodeValue(n)));
                break;

            case Types::String :
            case Types::RString :
            case Types::VarString :
                retval.value(#value, getXmlNodeValue(n));
                break;
        }
        return retval;
    }

    client server static Exception warning(SysInfoLogStr txt, URL helpUrl = '', SysInfoAction _sysInfoAction = null)
    {
        return infolog.add(Exception::Warning, getPrefix()+txt, helpUrl, _sysInfoAction, false, infolog.resolveContextLabelId(txt));
    }

    client static boolean webReportHasMethod(
        ReportRun        rr,
        IdentifierName methodName
        )
    {
        //validate arguments before using them
        if (rr == null)
            return false;

        return TreeNode::findNode('\\Web\\Web Reports\\'+rr.name()+'\\methods\\'+methodName) ? true : false;
    }

    // In this global method, we are storing the newly created WebSession object
    // in Session block.  Earlier it was being stored
    // in GlobalCache, which was not giving the performance as expected.
    // Hence we are storing it in Session block now. (thru newly introduced
    // property in infolog).
    [SysObsolete('The EP functionality is deprecated and should not be used.', true, 07\01\2016)]
    server client static Object webSession(Name appName = '',boolean initnew = false, CompanyId company = '')
    {
        return null;
    }

    /// <summary>
    /// Retrieves a sequence number based on the latest occurrence of the first day of the week in the
    /// year, where that day is before or on the input date, all according to local settings.
    /// </summary>
    /// <param name="_curDate">
    /// The date for which the week-of-year information is desired.
    /// </param>
    /// <returns>
    /// A value between 1 and 53.
    /// </returns>
    /// <remarks>
    /// The value returned by this method is affected by the local settings of the computer. For more
    /// information, you can search the Windows registry and the Web for the strings <c>iFirstDayOfWeek</c>
    /// and <c>iFirstWeekOfYear</c>.This method generally returns the sequence number of the latest Sunday
    /// of the year before or on the input date value unless there are no more Sundays that year. The
    /// return values for dates near the start or end of the year are determined by various details.Assume
    /// that the local settings have Sunday as the first day of the week, which means
    /// <c>iFirstDayOfWeek=0</c>. Also assume that January 1 is always considered to be part of the first
    /// week of the year, which means <c>iFirstWeekOfYear=0</c>. In this context, consider the year 2003.
    /// The first day of 2003 is a Wednesday. This means an input date in January of Saturday 4\1\2003
    /// returns 1, and the next day Sunday 5\1\2003 returns 2.The last day of 2003 is also a Wednesday. An
    /// input of Saturday 27\12\2003 returns 52, and Sunday 28\12\2003 returns 1 because there are no more
    /// Sundays that year.Unlike the <c>weekOfYear</c> method, the <c>wkOfYr</c> function calculates a
    /// return value according to the ISO 8601 specification.
    /// </remarks>
    [SysObsoleteAttribute(@"This method is deprecated and will be removed in future releases.
Please use the DateTimeUtil::getWeekOfYear method by specifying the locale to use.
To retrieve the preferred locale of the user, use the method xSession.PreferredLocale.", false, 03\02\2016)]
    static int weekOfYear(date _curDate)
    {
        int firstDayOfWeek;
        int firstWeekOfYear;
        int dowJan1st;
        int dowCurDate;
        int week;
        date normDate;
        date testDate;
        #TimeConstants

        normDate = dateStartYr(_curDate);

        // Get locale settings.
        firstDayOfWeek = firstDayOfWeek();
        firstWeekOfYear = firstWeekOfYear();

        // The dayofwk(...) function returns
        // a value between 1 and 7.
        // The logic below is expecting 0 - 6 so
        // the 1 is subtracted from the result.
        dowJan1st = dayOfWk(normDate) - 1;
        dowCurDate = dayOfWk(_curDate) - 1;

        // The dayofwk function used above returns
        // the ISO-8601 day of week, where Monday is 1
        // and recall that the 1 was subtracted from the result
        // to get a value between (0 - 6).
        //
        // If the locale settings (firstDayOfWeek) is
        // not Monay (i.e. > 0) then the caclulated
        // day of week results need to be adjusted
        // so they align with the locale setting.
        if (firstDayOfWeek > 0)
        {
            dowJan1st = (dowJan1st + (#DaysPerWeek - firstDayOfWeek)) mod #DaysPerWeek;
            dowCurDate = (dowCurDate + (#DaysPerWeek - firstDayOfWeek)) mod #DaysPerWeek;
        }

        // The normDate represents a day in the first week of the year.
        // The following will adjust the normDate so the day of week
        // will align with the target date.
        //
        // For example: if normDate is Sunday and target date is Tuesday
        //              the normDate will be adjusted to Tuesday
        //              of the 1st week of the year.
        normDate = normDate + (dowCurDate - dowJan1st);

        switch(firstWeekOfYear)
        {
            case 0: // Week starts on Jan 1
                week = any2Int((_curDate - normDate) / #DaysPerWeek) + 1; // calculate week number.

                if (week > 52)
                {
                    // Look at the last day of the week and compare it
                    // to the target date.  If the year is different
                    // then the target date is part of week 1 for next year.
                    testDate = _curDate + ((#DaysPerWeek - 1) - dowCurDate);
                    if (year(testDate) != year(_curDate))
                    {
                        week = 1;
                    }
                }
                break;

            case 1: // First full week.
                        if (dowJan1st != 0)
                {
                    // If day of week for Jan 1st is not on the
                    // the 1st day of the week (0), then
                    // adjust the normDate to next week (the 1st full week).
                    normDate = normDate + #DaysPerWeek;
                }

                if (_curDate < normDate)
                {
                    // The target date is prior to the 1st week, so
                    // it considered to be part of last year.
                    // Get the week for 12/31 of last year.
                    week = weekOfYear(dateStartYr(_curDate) - 1);
                }
                else
                {
                    week = any2Int((_curDate - normDate) / #DaysPerWeek) + 1; // calculate the week number.
                }
                break;

            case 2: // First 4-day week
                {
                    if (firstDayOfWeek == 0)
                    {
                        // Use ISO-8601 when first day of week is Monday.
                        week = wkOfYr(_curdate);
                    }
                    else
                    {
                        if (dowJan1st > 3)
                        {
                            // If 1/1 starts on the 5th day
                            // Then adust normDate to next week (first 4-day week).
                            normDate = normDate + #DaysPerWeek;
                        }

                        if (_curDate < normDate)
                        {
                            // The target date is prior to the 1st week, so
                            // it considered to be part of last year.
                            // Get the week for 12/31 of last year.
                            week = weekOfYear(dateStartYr(_curDate) - 1);
                        }
                        else
                        {
                            week = any2Int((_curDate - normDate) / #DaysPerWeek) + 1; // Calculate the week number.
                            if (week > 52 && dowCurDate < 3)
                            {
                                // Check the 5th day of the target week.
                                // If the year is different then the target date
                                // is part of week 1 for next year.
                                testDate = _curDate + (3 - dowCurDate);
                                if (year(testDate) != year(_curDate))
                                {
                                    week = 1;
                                }
                            }
                        }
                    }
                }
        }

        return week;
    }

    static Types xmlGetTypeFromSpelling(str typeName)
    {
        switch (typeName)
        {
            case 'int'      : return Types::Integer;
            case 'real'     : return Types::Real;
            case 'date'     : return Types::Date;
            case 'str'      : return Types::String;
            case 'enum'     : return Types::Enum;
            case 'class'    : return Types::Class;
            case 'container': return Types::Container;
            case 'record'   : return Types::Record;
            case 'int64'    : return Types::Int64;
            case 'guid'     : return Types::Guid;
            case 'utcdatetime' : return Types::UtcDateTime;
            case 'datetime' : return Types::UtcDateTime;
            case 'time'     : return Types::Time;
        }
        return Types::void;
    }

    // Returns a XML string describing the given value of the given type.
    static str xmlString(anytype value, Types theType, int indent=0)
    {
        str r;
        Object o;
        Common record;

        // Determine whether the string contains <>&
        str legalXMLString(str s)
        {
            int i, len = strLen(s);
            boolean noProblem = strFind(s, '<&>', 1, len) == 0;
            str res;

            if (noProblem)
            {
                res = s;
            }
            else
            {
                // Check if the string contains the string "]]>", that is used to delimit
                // a CDATA section. If so, the > must be escaped, yielding "]]&gt;"
                i = 1;
                do
                {
                    i = strScan(s, ']]>', i, len);
                    if (i == 0)
                    {
                        break;
                    }
                    else
                    {
                        s = strDel(s, i, 3);
                        s = strIns(s, ']]&gt;', i);
                        len += 3;   // Length has increased because ]]> changed to ]]&gt;
                    }
                }
                while (true);

                res = strFmt('<![CDATA[%1]]>', s);
            }
            return res;
        }

        str typeToString(Types t)
        {
            switch (t)
            {
                case Types::Container   : return 'container';
                case Types::Date        : return 'date';
                case Types::Time        : return 'time';
                case Types::UtcDateTime    : return 'datetime';
                case Types::Enum        : return 'enum';
                case Types::Integer     : return 'int';
                case Types::Real        : return 'real';
                case Types::Record      : return 'record';
                case Types::VarString   :
                case Types::String      : return 'str';
                case Types::BLOB        : return 'blob';
                case Types::Int64       : return 'int64';
                case Types::Guid        : return 'guid';
            }
            
            ApplicationPlatformTelemetry::LogEventMarker(ApplicationPlatformTelemetryLevel::Error, classStr(Global), funcName(), 'Value Serialization', strFmt('Type \'%1\' is not serializable.', t));            
            return 'unknown';
        }

        str containerXML(container c, int _indent)
        {
            var sb = new System.Text.StringBuilder();
            int i;
            Types t;
            container contents;

            sb.Append(strRep(' ', _indent));
            if (extendedSerialization)
            {
                sb.AppendLine(strFmt('<container appVersion="%1" packVersion="%2">', ApplicationVersion::buildNo(), globalXMLSerializationVersion));
            }
            else
            {
                sb.AppendLine('<container>');
            }

            for (i = 1; i <= conLen(c); i++)
            {
                var valuePeek = conPeek(c, i);                
                var valuePeekObject = valuePeek as Microsoft.Dynamics.Ax.Xpp.AxShared.IEdtArray;
                t = typeOf(valuePeek);

                // if the collection is array
                if (extendedSerialization && (valuePeekObject != null))
                {
                    sb.Append(strRep(' ', _indent+4));
                    sb.Append('<element type=\"array\" ');
                    int length = valuePeekObject.Size;
                    sb.Append(' baseType=\"');
                    str baseType;
                    container elements = extendedTypeArrayToContainer(valuePeekObject);
                    if (length > 0)
                    {
                        // get the base type from one of the children
                        var firstChild = conpeek(elements, 1);
                        baseType = typeToString(typeOf(firstChild));
                    }
                    else
                    {
                        baseType = typeToString(t);
                    }
                    sb.Append(baseType);
                    sb.Append('\" ');
                    sb.Append('length=\"');
                    sb.Append(length);
                    sb.Append('\">');
                    sb.Append(xmlString(elements, Types::Container, 0));
                    sb.AppendLine('</element>');
                }
                else if (t == Types::Container)
                {
                    contents = conPeek(c, i);
                    if (conLen(contents) == 1 && typeOf(conPeek(contents, 1)) == Types::BLOB)
                    {
                        sb.Append(strRep(' ', _indent+4));
                        sb.Append('<element type=\"');
                        sb.Append(typeToString(Types::BLOB));
                        sb.Append('\" nested=\"true\">');
                        sb.Append(BinData::dataToString(contents));
                        sb.AppendLine('</element>');
                    }
                    else
                    {
                        sb.Append(strRep(' ', _indent+4));
                        sb.Append('<element type=\"');
                        sb.Append(typeToString(t));
                        sb.AppendLine('\">');
                        sb.Append(xmlString(valuePeek, t, indent+4+4));
                        sb.Append(strRep(' ', _indent+4));
                        sb.AppendLine('</element>');
                    }
                }
                else if (t == Types::BLOB)
                {
                    sb.Append(strRep(' ', _indent+4));
                    sb.Append('<element type=\"');
                    sb.Append(typeToString(Types::BLOB));
                    sb.Append('\" nested=\"false\">');
                    sb.Append(BinData::dataToString(valuePeek));
                    sb.AppendLine('</element>');
                }
                else 
                {
                    sb.Append(strRep(' ', _indent+4));
                    sb.Append('<element type=\"');
                    sb.Append(typeToString(t));  
                    sb.Append('\"');
                    if (extendedSerialization)
                    {
                        switch (t)
                        {
                            case Types::Record:
                                Common recordLocal = conPeek(c, i);
                                sb.Append(strFmt(' id=\"%1\"', recordLocal.RecId));
                                break;
                            case Types::Enum:
                                System.Object dotNetEnumValue = any2DotNetObject(valuePeek);
                                if (dotNetEnumValue is System.Boolean)
                                {
                                    sb.Append(strFmt(' enumtype=\"%1" enumsymbol=\"%2\"', #CSBoolean, valuePeek ? 'true': 'false'));
                                }
                                else
                                {
                                    SysDictEnum enum = new SysDictEnum(enumName2Id(dotNetEnumValue.GetType().Name));
                                    if (enum)
                                    {
                                        sb.Append(strFmt(' enumtype=\"%1" enumsymbol=\"%2\"', enum.Name(), enum.value2Symbol(valuePeek)));
                                    }
                                }
                                break;
                        }
                    }
                    sb.Append('>');
                    sb.Append(xmlString(valuePeek, t, 0));
                    sb.AppendLine('</element>');
                }
            }

            sb.Append(strRep(' ', _indent));
            sb.AppendLine('</container>');
            
            return sb.ToString();
        }

        str blobXML(container c, int _indent)
        {
            str result;

            if (conLen(c) == 1 && typeOf(conPeek(c, 1)) == Types::BLOB)
            {
                result += strRep(' ', _indent) + '<element type=\"' + typeToString(Types::BLOB) + '\">';
                result += BinData::dataToString(c);
                result += '</element>\n';
                return result;
            }
            else
            {
                return containerXML(c, _indent);
            }
        }

        r = strRep(' ', indent);

        switch (theType)
        {
            case Types::RString:
            case Types::VarString:
            case Types::String:     r += legalXMLString(value);
                break;

            case Types::Integer:    r += int2str(value); break;
            case Types::Real:       r += num2str(value,
                        /* min chars */ 1,
                        /* decimals */  2,
                        /* decimals = point */ 1,
                        /* no thousand sep */ 0); break;

            case Types::Date:       // Use ISO-8601, that is XML standard for data w.o. time
                r += date2str(value, 321,  2, 3, 2, 3, 4, DateFlags::None);
                break;

            case Types::Time:       r += time2StrHM(value); break;
            case Types::Enum:       // Return the ordinal value
                r += int2str(value); 
                break;

            case Types::UtcDateTime:   r += datetime2str(value, DateFlags::None); break;
            case Types::Container:  r = containerXML(value, indent); break;

            case Types::Record:     record = value;
                r = record.xml(indent);
                break;
            case Types::Class:      o = value;
                r = o.xml(indent);
                break;
            case Types::UserType:   /* Only base types arrive here */ r = 'User type???'; break;
            case Types::AnyType:    r += strFmt('%1', value); break;
            case Types::BLOB:       r = blobXML(value, indent); break;
            case Types::void:       /* void values may not be embedded in records */ break;
            case Types::Int64:      r += int642str(value); break;
            case Types::Guid:       r += guid2str(value); break;
            default :               r += '??? ' + enum2str(theType) + ' ???';
        }
        return r;
    }

    static int yearDiff(date d1, date d2)
    {
        date boundary;
        int offset;

        if ( d1 < d2)
        {
            boundary = mkDate(dayOfMth(d1), mthOfYr(d1), year(d2));
            offset = (d2 - boundary) < 0 ? -1 : 0;
        }
        else
        {
            boundary = mkDate(dayOfMth(d2), mthOfYr(d2), year(d1));
            offset = (d1 - boundary) < 0 ? 1 : 0;
        }

        return year(d1) - year (d2) - offset ;
    }

    public static System.Threading.Tasks.Task runAsync(int runAsClassId, str runAsStaticMethodName, container parms, System.Threading.CancellationToken cancellationToken = System.Threading.CancellationToken::None, int callbackClassId = 0, str callbackStaticMethodName = '', container asyncState = connull(), str userId = '', str company = '', str language = '', str partitionKey = '', System.Threading.Tasks.TaskCreationOptions options = System.Threading.Tasks.TaskCreationOptions::None)
    {
        return xGlobal::runAsync(runAsClassId, runAsStaticMethodName, parms, cancellationToken, callbackClassId, callbackStaticMethodName, asyncState, userId, company, language, partitionKey, options);
    }

    static Application appl()
    {
        return ApplicationVariables::appl();
    }

    static Info infolog(boolean _create = true)
    {
        return ApplicationVariables::infolog(_create);
    }

    static ClassFactory classFactory()
    {
        return ApplicationVariables::classFactory();
    }

    /// <summary>
    /// Converts the hexadecimal value to RGB container
    /// </summary>
    /// <param name="_hexValue">
    /// The hexadecimal value to convert.
    /// </param>
    /// <returns>
    /// Container of the RGB representation of the color.
    /// </returns>
    public static container hex2RGB(SysColorHex _hexValue)
    {
        container rgbCon = conNull();

        rgbCon += hex2Int(subStr(_hexValue, 1, 2));
        rgbCon += hex2Int(subStr(_hexValue, 3, 2));
        rgbCon += hex2Int(subStr(_hexValue, 5, 2));

        return rgbCon;
    }

    /// <summary>
    /// Verifies if the Windows Identity of the current process is allowed to control event tracing sessions.
    /// </summary>
    /// <returns>
    /// true if the Windows Identity of the current process is allowed to control event tracing sessions, false otherwise.
    /// </returns>
    /// <remarks>
    /// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
    /// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
    /// sessions, add them to the Performance Log Users group.
    ///
    /// Windows XP and Windows 2000:  Anyone can control a trace session.
    /// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
    /// specified folder.
    /// </remarks>
    private static boolean isAllowedToStartEventTracing()
    {
        #define.NTAccountType('System.Security.Principal.NTAccount')

        System.Security.Principal.WindowsIdentity               windowsIdentity;
        System.Security.Principal.WindowsPrincipal              windowsPrincipal;
        System.Security.Principal.SecurityIdentifier            userSid;
        System.Security.Principal.SecurityIdentifier            domainSid;
        System.Security.Principal.SecurityIdentifier            perfLogUserGroupSid;
        System.Security.Principal.IdentityReferenceCollection   identityRefCollection;
        System.Security.Principal.IdentityReference             identityReference;
        System.Security.Principal.NTAccount                     groupSid;
        System.Security.Principal.NTAccount                     perfGroupSid;
        int                                                     g, groupCount;

        windowsIdentity = System.Security.Principal.WindowsIdentity::GetCurrent();
        windowsPrincipal = new System.Security.Principal.WindowsPrincipal(windowsIdentity);

        // Windows users with administrative privileges can control event tracing sessions.
        if (windowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole::Administrator))
        {
            return true;
        }

        userSid = windowsIdentity.get_User();
        domainSid = userSid.get_AccountDomainSid();

        // Services running as LocalSystem, LocalService, NetworkService can control event tracing sessions.
        if (userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::NetworkServiceSid, domainSid)) ||
        userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::LocalServiceSid, domainSid)) ||
        userSid.Equals( new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::LocalSystemSid, domainSid)))
        {
            return true;
        }

        perfLogUserGroupSid = new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType::BuiltinPerformanceLoggingUsersSid, domainSid);
        perfGroupSid = perfLogUserGroupSid.Translate(System.Type::GetType(#NTAccountType));

        identityRefCollection = windowsIdentity.get_Groups();
        groupCount = identityRefCollection.get_Count();

        for (g = 0; g < groupCount; g++)
        {
            identityReference = identityRefCollection.get_Item(g);

            try
            {
                groupSid = identityReference.Translate(System.Type::GetType(#NTAccountType));

                // Windows users in the Performance Log Users group can control event tracing sessions.
                if (perfGroupSid.Equals(groupSid))
                {
                    return true;
                }
            }
            catch
            {
                continue;
            }
        }

        return false;
    }

    /// <summary>
    /// Verifies if the Windows Identity of the account running the AX Client is allowed to control event tracing sessions.
    /// </summary>
    /// <returns>
    /// true if the Windows Identity of the account running the AX Client is allowed to control event tracing sessions, false otherwise.
    /// </returns>
    /// <remarks>
    /// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
    /// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
    /// sessions, add them to the Performance Log Users group.
    ///
    /// Windows XP and Windows 2000:  Anyone can control a trace session.
    /// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
    /// specified folder.
    /// </remarks>
    public static boolean isClientAllowedToControlEventTracing()
    {
        return isAllowedToStartEventTracing();
    }

    /// <summary>
    /// Validates whether the specified regular expression finds a match in the specified input string.
    /// </summary>
    /// <param name="_input">
    /// The string to search for the match.
    /// </param>
    /// <param name="_pattern">
    /// The regular expression pattern to match.
    /// </param>
    /// <returns>
    /// true if the regular expression finds a match; otherwise, false.
    /// </returns>
    public static boolean isMatch(
        str _input,
        str _pattern)
    {
        System.Text.RegularExpressions.Regex regEx;

        regEx = new System.Text.RegularExpressions.Regex(_pattern);
        return regEx.IsMatch(_input);
    }

    /// <summary>
    /// Verifies if the Windows Identity of the account running the AOS process is allowed to control event tracing sessions.
    /// </summary>
    /// <returns>
    /// true if the Windows Identity of the account running the AOS process is allowed to control event tracing sessions, false otherwise.
    /// </returns>
    /// <remarks>
    /// Only users with administrative privileges, users in the Performance Log Users group, and services running as LocalSystem,
    /// LocalService, NetworkService can control event tracing sessions. To grant a restricted user the ability to control trace
    /// sessions, add them to the Performance Log Users group.
    ///
    /// Windows XP and Windows 2000:  Anyone can control a trace session.
    /// If the user is a member of the Performance Log Users group, they may not have permission to create the log file in the
    /// specified folder.
    /// </remarks>
    public static boolean isServerAllowedToControlEventTracing()
    {
        return isAllowedToStartEventTracing();
    }

    /// <summary>
    /// Converts RGB values to hexadecimal.
    /// </summary>
    /// <param name="_r">
    /// Red value.
    /// </param>
    /// <param name="_g">
    /// Green value.
    /// </param>
    /// <param name="_b">
    /// Blue value.
    /// </param>
    /// <returns>
    /// The hexadecimal representation of the RGB values.
    /// </returns>
    public static SysColorHex rgb2Hex(RGBintR _r, RGBintG _g, RGBintB _b)
    {
        SysColorHex colorHex;

        colorHex = int2Hex(_r, 2);
        colorHex += int2Hex(_g, 2);
        colorHex += int2Hex(_b, 2);

        return colorHex;
    }

    /// <summary>
    /// Finds the table buffer of the specified type that is (maybe indirectly) joined to the specified table buffer.
    /// </summary>
    /// <param name="_record">
    /// The base table buffer.
    /// </param>
    /// <param name="_joinedFormDataSource">
    /// The <c>FormDataSource</c> class to find.
    /// </param>
    /// <returns>
    /// The found record or Common if nothing was found.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An exception is thrown if the <paramref name="_record"/> parameter is not referencing a <c>FormDataSource</c> object.
    /// An exception is thrown if the <paramref name="_joinedFormDataSource"/> is null.
    /// </exception>
    public static Common formJoinedRecord(Common _record, FormDataSource _joinedFormDataSource)
    {
        Common          current = _record;
        FormDataSource  currentFormDataSource = current.dataSource();

        if (!currentFormDataSource
            || !_joinedFormDataSource)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        while (current.TableId != tableNum(Common)
            && (!currentFormDataSource || currentFormDataSource.name() != _joinedFormDataSource.name()))
        {
            current = current.joinChild();
            currentFormDataSource = current.dataSource();
        }

        if (current.TableId == tableNum(Common)
            || (!currentFormDataSource || currentFormDataSource.name() != _joinedFormDataSource.name()))
        {
            current = _record;
            currentFormDataSource = current.dataSource();

            while (current.TableId != tableNum(Common)
                && (!currentFormDataSource || currentFormDataSource.name() != _joinedFormDataSource.name()))
            {
                current = current.joinParent();
                currentFormDataSource = current.dataSource();
            }
        }

        return current;
    }

    public static FormDatasource getFirstRootDatasourceOnFormRun(FormRun formRun)
    {
        List rootDatasources;
        ListEnumerator rootDSEnum;
        FormDataSource firstRootDatasource;

        rootDatasources = formRun.rootFormDataSources();
        rootDSEnum = rootDatasources.getEnumerator();
        while (rootDSEnum.moveNext())
        {
            firstRootDatasource = rootDSEnum.current();
            break;
        }

        return firstRootDatasource;
    }

    public static FormBuildDatasource getFirstRootDatasourceOnForm(Form form)
    {
        List rootDatasources;
        ListEnumerator rootDSEnum;
        FormBuildDataSource firstRootDatasource;

        rootDatasources = form.rootFormDataSources();
        rootDSEnum = rootDatasources.getEnumerator();
        while (rootDSEnum.moveNext())
        {
            firstRootDatasource = rootDSEnum.current();
            break;
        }

        return firstRootDatasource;
    }

    /// <summary>
    ///    Determines whether the specified table physically exists in the database.
    /// </summary>
    /// <param name="_tableId">
    /// The ID of the table to check the existence in the database.
    /// </param>
    /// <returns>
    ///    true if the table physically exists in the database; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The table may not yet physically exist in the database during an upgrade scenario.
    /// </remarks>
    public static boolean isPhysicallyExistingInDB(TableId _tableId)
    {
        SqlDictionary sqlDictionary;
        
        select firstonly RecId from sqlDictionary
            where sqlDictionary.TabId == _tableId;
        
        if (sqlDictionary.RecId == 0)
        {
            // The table does not yet physically exist in the database.
            return false;
        }
        
        return true;
    }

    /// <summary>
    /// Casts any variables to <c>anytype</c>
    /// </summary>
    /// <param name = "_x">A value that will be cast to <c>anytype</c></param>
    /// <returns>The value passed to this method, cast to <c>anytype</c></returns>
    public static anytype toanytype(anytype _x)
    {
        return _x;
    }

    public static str editEncryptedField(Common _common, str value, FieldId _fieldId, boolean _set)
    {
        // log the activity
        Global::logEncryptDecryptActivity(_common, _fieldId, _set);

        if (_set)
        {
            _common.(_fieldId) = appl.EncryptForPurpose(value, _common.encryptionPurpose(_fieldId));

            return value;
        }
        else
        {
            if (conLen(_common.(_fieldId)) > 0)
            {
                if (_common.RecId > 0 && _common.orig().(_fieldId) == _common.(_fieldId))
                {
                    SysEncryptionLog::logField(_common, _fieldId, ReadWrite::read);
                }

                return appl.DecryptForPurpose(_common.(_fieldId), _common.encryptionPurpose(_fieldId));
            }
            else
            {
                return "";
            }
        }
    }

    public static str editEncryptedStringField(Common _common, str value, FieldId _fieldId, boolean _set)
    {
        // log the activity
        Global::logEncryptDecryptActivity(_common, _fieldId, _set);
        System.Exception ex;

        try
        {
            if (_set)
            {
                _common.(_fieldId) = appl.EncryptToStringForPurpose(value, _common.encryptionPurpose(_fieldId));
            
                return value;
            }
            else
            {
                if (_common.(_fieldId))
                {
                    if (_common.RecId > 0 && _common.orig().(_fieldId) == _common.(_fieldId))
                    {
                        SysEncryptionLog::logStringField(_common, _fieldId, ReadWrite::read);
                    }

                    return appl.DecryptFromStringForPurpose(_common.(_fieldId), _common.encryptionPurpose(_fieldId));
                }
                else
                {
                    return null;
                }
            }
        }
        catch(Exception::CLRError)
        {
            //Get the table name and fieldname for which encryption or decryption was invoked
            str tableName = tableId2PName(_common.TableId);
            str fieldName = fieldId2Name(_common.TableId, _fieldId);

            ex = ClrInterop::getLastException();

            if (ex != null && ex is System.Reflection.TargetInvocationException)
            {
                // Strip the inner reflection exception
                ex = ex.get_InnerException();
            }

            //save entire trace for later use
            str originalException = ex.ToString();
            
            while(ex && ex.InnerException)
            {
                if(ex.InnerException is Microsoft.Dynamics.AX.Configuration.CertificateHandler.NoCertificateFoundException)
                {
                    throw error(strFmt("@Security:EncryptionEngineCertificateNotFoundException", tableName, fieldName, originalException));
                }

                ex = ex.InnerException;
            }
            
            throw error(strFmt("@Security:EncryptionEngineException", tableName, fieldName, originalException));
        }
    }

    public static void handleEncryptedTablePostUpdate(Common _common)
    {
        SysEncryptionLog::logOperation(_common, ReadWrite::Write);
    }

    public static void handleEncryptedTablePostInsert(Common _common)
    {
        SysEncryptionLog::logOperation(_common, ReadWrite::Write);
    }

    public static void handleEncryptedTablePreUpdate(Common _common)
    {
    }

    public static void handleEncryptedTablePreInsert(Common _common)
    {
    }

    /// <summary>
    /// Gets the ID of the current company.
    /// </summary>
    /// <returns>
    /// The ID of the <c>CompanyInfo</c> record associated with the current company.
    /// </returns>
    public static RefRecId curCompanyId()
    {
        return xGlobal::getCompanyId(curExt());
    }

    /// <summary>
    /// Gets the implementing type of the specified interface.
    /// </summary>
    /// <param name="_type">The type of the parameter.</param>
    /// <param name="_throwOnNullValue">Whether to throw on null instance retrieved.</param>
    /// <returns>
    /// The instance of the implementing object.
    /// </returns>
    [Hookable(false)]
    public static System.Object defaultInstance(System.Type _type, boolean _throwOnNullValue = true)
    {
        if (!_type)
        {
            throw error(error::missingParameter(null));
        }

        var instance = SysServiceRegistryManager::Retrieve(_type);

        if (!instance && _throwOnNullValue)
        {
            throw error(strFmt(errorDefaultInstanceNotFound, _type.Name));
        }

        return instance;
    }

    /// <summary>
    /// Gets the implementing type of the specified interface.
    /// </summary>
    /// <param name="_type">The type of the parameter.</param>
    /// <param name="_owningType">The owning type.</param>
    /// <param name="_throwOnNullValue">Whether to throw on null instance retrieved.</param>
    /// <returns>
    /// The instance of the implementing object.
    /// </returns>
    [Hookable(false)]
    public static System.Object defaultInstanceFor(System.Type _type, System.Type _owningType, boolean _throwOnNullValue = true)
    {
        if (!_type || !_owningType)
        {
            throw error(error::missingParameter(null));
        }

        var instance = SysServiceRegistryManager::RetrieveForOwner(_type, _owningType);

        if (!instance && _throwOnNullValue)
        {
            throw error(strFmt(errorDefaultInstanceNotFound, _type.Name));
        }
        return instance;
    }

    /// <summary>
    /// Gets the implementing type of the specified interface.
    /// </summary>
    /// <param name="_type">The type of the parameter.</param>
    /// <param name="_owningTypeName">The owning type name.</param>
    /// <param name="_throwOnNullValue">Whether to throw on null instance retrieved.</param>
    /// <returns>
    /// The instance of the implementing object.
    /// </returns>
    [Hookable(false)]
    public static System.Object defaultInstanceForName(System.Type _type, str _owningTypeName, boolean _throwOnNullValue = true)
    {
        if (!_type || !_owningTypeName)
        {
            throw error(error::missingParameter(null));
        }

        var instance = SysServiceRegistryManager::RetrieveForOwnerName(_type, _owningTypeName);

        if (!instance && _throwOnNullValue)
        {
            throw error(strFmt(errorDefaultInstanceNotFound, _type.Name));
        }
        return instance;
    }

    /// <summary>
    /// Gets the dot net type representation of the type specified.
    /// </summary>
    /// <param name="_elementName">The name of the element in the global X++ namespace.</param>
    /// <returns>
    /// The dot net type instance. 
    /// </returns>
    [Hookable(false)]
    public static System.Type dotnetTypeOf(str _elementName)
    {
        System.Type type = Microsoft.Dynamics.Ax.Xpp.ReflectionCallHelper::getType(_elementName);
        if (type == null)
        {
            throw error(error::missingParameter(null));
        }
        return type;
    }

    /// <summary>
    /// Logs the encryption activity to audit log
    /// </summary>
    /// <param name="_common">Table record reference</param>
    /// <param name="_fieldId">Table record reference</param>
    /// <param name="_set">The operation: if true the operation is to encrypt; if false the operation is to decrypt</param>
    [Hookable(false)]
    public static void logEncryptDecryptActivity(Common _common, FieldId _fieldId, boolean _set)
    {
        // log the limit string length of the fieldId
        DictField encryptionField = SysDictField::findFieldById(_common.TableId, _fieldId);
        if(encryptionField)
        {
            SystemRuntimeEventSource::EventWriteEncryptionFieldLimitSize(_common.TableId, _fieldId, encryptionField.stringLen());
        }
        else
        {
            // log error message
            SystemRuntimeEventSource::EventWriteEncryptionFieldInfoErrorMessage(_common.TableId, _fieldId, 0);
        }
        
        if (!_common)
        {
            return;
        }

        try
        {
            // Add to audit log
            Map activityPropertyMap = new Map(Types::String, Types::String);
            activityPropertyMap.insert("TableName", tableId2Name(_common.TableId));
            activityPropertyMap.insert("FieldName", fieldId2Name(_common.TableId, _fieldId));
            activityPropertyMap.insert("Operation", _set ? "Encrypt" : "Decrypt");

            str auditCategory = IfxAuditHelper::AuditCategory_ObjectManagement;
            str operationName = strFmt(IfxAuditHelper::OperationName_ActivityFormatStr, EncryptDecryptCategoryName, staticMethodStr(Global, editEncryptedField));
            str operationResult = IfxAuditHelper::OperationResult_Success;
            str callerIdentity = guid2Str(curUserGuid());
            str callerIdentityType = IfxAuditHelper::CallerIdentityType_ObjectID;
            str requestId = "";
            str requestDescription = IfxAuditHelper::activityPropertyMap2RequestDescription(activityPropertyMap);

            IfxAuditHelper::logManagementAuditEvent(
                auditCategory,
                operationName,
                operationResult,
                callerIdentity,
                callerIdentityType,
                requestId,
                requestDescription);
        }
        catch
        {
            // instrument the error
            SystemRuntimeEventSource::EventWriteIfxLoggerException(classStr(Global), staticMethodStr(Global, logEncryptDecryptActivity), CLRInterop::getLastException().ToString(), "");
        }
    }

    /// <summary>
    /// Retrieves the NPS setting by url
    /// This method is used from the kernel and should not be modified.
    /// </summary>
    /// <returns>
    /// Operators name
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnly, SysObsolete('NPS configuration is now controlled via SysClientNpsManager', false, 17\03\2023)]
    public static boolean isNpsEnabled()
    {
        if (!isNpsEnabledProcessed) {
            if (GetDeploymentEndPoint() == DeploymentEndpoint::usgov) 
            {
                isNpsEnabled = false;
            }
            else 
            {
                isNpsEnabled = true;
            }
            isNpsEnabledProcessed = true;
        }

        return isNpsEnabled;
    }

    /// <summary>
    /// Retrieves the deployment endpoint enum
    /// This method is used from the kernel and should not be modified.
    /// </summary>
    [Hookable(false)]
    public static DeploymentEndpoint GetDeploymentEndPoint()
    {
        boolean manualHostUrlSet = false;
        if (!isEndPointProcessed)
        {
            // this is used for testing but needs to be hooked in product code
            str hostUrlFormat = Global::overrideHostUrlFormat();

            if (hostUrlFormat != '')
            {
                manualHostUrlSet = true;
            }
            
            // if we manually set for testing or if we are onPrem skip
            if (!(manualHostUrlSet || Global::isOnPremEnvironment()))
            {
                // get it from the environment, i.e. web.config
                var infrastructureConfig = EnvironmentFactory::GetApplicationEnvironment().Infrastructure;
                System.Uri hostUrl = new System.Uri(infrastructureConfig.HostUrl);

                if (hostUrl)
                {
                    hostUrlFormat = hostUrl.GetLeftPart(System.UriPartial::Authority).ToLowerInvariant();
                }
            }

            // inspect the endpoint format if not custom and onPrem - default
            if (!manualHostUrlSet && Global::isOnPremEnvironment())
            {
                deploymentEndPoint =  DeploymentEndpoint::default;
            }
            else
            {
                // not on prem so process
                if (strEndsWith(hostUrlFormat, enum2Str(DeploymentEndpoint::usgov)) ||
                    strEndsWith(hostUrlFormat, enum2Str(DeploymentEndpoint::usgov) + '/'))
                {
                    deploymentEndPoint = DeploymentEndpoint::usgov;
                }
                else if (strEndsWith(hostUrlFormat, enum2Str(DeploymentEndpoint::mooncake)) ||
                         strEndsWith(hostUrlFormat, enum2Str(DeploymentEndpoint::mooncake) + '/'))
                {
                    deploymentEndPoint = DeploymentEndpoint::mooncake;
                }
                else
                {
                    deploymentEndPoint = DeploymentEndpoint::default;
                }
            }

            isEndPointProcessed = true;
        }
        return deploymentEndPoint;
    }

    /// <summary>
    /// Gets or sets the override value for the HostUrl setting
    /// </summary>
    /// <param name = "value">Override value to use</param>
    /// <remarks>Used for testing purposes only!</remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnly]
    internal static str overrideHostUrlFormat(str value = hostUrlFormatOverride)
    {
        hostUrlFormatOverride = value;
        return hostUrlFormatOverride;
    }

}